<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>TypeScript HTML App</title>
  <style>
    html, body {
      overflow: hidden;
      margin: 0;
      font-family: Arial, sans-serif;
      padding-top: constant(safe-area-inset-top);
      padding-top: env(safe-area-inset-top);
    }
    html {
      overscroll-behavior-x: none;
      touch-action: none;
      background-color: white !important;
    }
    body {
      display: flex;
      flex-direction: column;
      height: calc(100vh - env(safe-area-inset-top));
      height: calc(100vh - constant(safe-area-inset-top));
      background: transparent;
      margin-top: 0 !important;
      padding-top: 0 !important;
      top: 0 !important;
    }
    
    body > canvas:only-child {
      width: 100%;
      height: 100%;
    }

    #call-button {
      position: absolute;
      left: 35px; /* è°ƒæ•´ä½ç½®ï¼Œè®©å®ƒç´§è´´ä¸Šä¼ æŒ‰é’®å³ä¾§ */
      bottom: 4px;
      width: 24px;
      height: 24px;
      background: rgba(33, 150, 243, 0.9);
      border: 1px solid rgba(33, 150, 243, 0.8);
      border-radius: 50%;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      z-index: 10;
      font-size: 12px;
      backdrop-filter: blur(2px);
    }

    #call-button:hover {
      background: rgba(25, 118, 210, 0.95);
      color: white;
      border-color: #1976D2;
      transform: scale(1.1);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    #call-button:active {
      transform: scale(0.95);
    }

    #video-button {
      position: absolute;
      left: 62px; /* è°ƒæ•´ä½ç½®ï¼Œè®©å®ƒç´§è´´ä¸Šä¼ æŒ‰é’®å³ä¾§ */
      bottom: 4px;
      width: 24px;
      height: 24px;
      background: rgba(33, 150, 243, 0.9);
      border: 1px solid rgba(33, 150, 243, 0.8);
      border-radius: 50%;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      z-index: 10;
      font-size: 12px;
      backdrop-filter: blur(2px);
    }

    #video-button:hover {
      background: rgba(25, 118, 210, 0.95);
      color: white;
      border-color: #1976D2;
      transform: scale(1.1);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    #video-button:active {
      transform: scale(0.95);
    }

    /* é€šè¯é¡µé¢æ ·å¼ */
    #call-page {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      z-index: 10000;
      flex-direction: column;  /* æ”¹ä¸ºå‚ç›´å¸ƒå±€ */
      align-items: center;
      transition: all 0.3s ease;
      box-sizing: border-box;
      padding-top: 40px;  /* æ·»åŠ é¡¶éƒ¨å†…è¾¹è· */
      padding-bottom: 120px;  /* ä¸ºåº•éƒ¨æŒ‰é’®ç•™ç©ºé—´ */
    }

    #call-avatar-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      min-height: 0;    /* æ·»åŠ è¿™è¡Œ */
      padding: 20px;    /* æ·»åŠ å†…è¾¹è· */
    }

    #call-avatar {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      border: 4px solid rgba(255,255,255,0.3);
      box-shadow: 0 8px 32px rgba(0,0,0,0.2);
    } 

    #call-controls {
      position: fixed;  /* æ”¹ä¸ºfixed */
      bottom: 0;        /* å›ºå®šåˆ°åº•éƒ¨ */
      left: 0;
      right: 0;
      padding: 20px;
      display: flex;
      justify-content: center;
      gap: 40px;
      z-index: 1000;
    }

    .call-control-btn {
      width: 60px;
      height: 60px;
      border: none;
      border-radius: 50%;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      transition: all 0.2s;
      box-shadow: 0 4px 16px rgba(0,0,0,0.2);
    }

    #end-call-btn {
      background: #f44336;
    }

    #end-call-btn:hover {
      background: #d32f2f;
      transform: scale(1.05);
    }

    #video-call-btn {
      background: #4CAF50;
    }

    #video-call-btn:hover {
      background: #45a049;
      transform: scale(1.05);
    }

    .call-message {
      padding: 8px 0;
      max-width: 100%;
      word-wrap: break-word;
      font-size: 16px;
      line-height: 1.5;
      opacity: 0;
      transform: translateY(20px);
      animation: slideInUp 0.5s ease forwards;
      text-align: left;  /* å·¦å¯¹é½ */
      white-space: pre-wrap;  /* æ”¯æŒæ¢è¡Œ */
    }

    .call-message.user {
      color: #ffffff;  /* ç”¨æˆ·æ¶ˆæ¯ç™½è‰² */
    }

    .call-message.bot {
      color: #333;  /* AIå›å¤æµ…ç°è‰² */
    }

    .call-message.fade-out {
      animation: fadeOutDown 0.5s ease forwards;
    }

    @keyframes slideInUp {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes fadeOutDown {
      to {
        opacity: 0;
        transform: translateY(-20px) scale(0.9);
      }
    }

    /* ç§»åŠ¨ç«¯é€‚é… */
    @media (max-width: 768px) {
      #call-avatar {
        width: 150px;
        height: 150px;
      }
      
      .call-control-btn {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }
      
      #call-controls {
        gap: 30px;
      }
    }
  </style>
  <script src="cordova.js"></script>
</head>
<body>
  <!-- é€šè¯é¡µé¢ -->
  <div id="call-page">
    <div id="call-avatar-container">
      <img id="call-avatar" src="" alt="AIå¥³å‹">
      <p id="call-timer" style="
        color: white;
        font-size: 20px;
        font-weight: bold;
        margin-top: 10px;">00:00</p>
      <p id="call-status" style="
        color: #4CAF50; 
        font-weight: bold; 
        margin-top: 5px; 
        display: none;">è†å¬ä¸­</p>
      <div id="call-messages-container" style="
        width: 90%;
        max-width: 500px;
        flex: 1;
        overflow-y: auto;
        padding: 20px 0;
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-top: 30px;">
    </div>
    </div>
    <div id="call-controls">
      <button id="end-call-btn" class="call-control-btn" title="ç»“æŸé€šè¯">ğŸ“</button>
      <button id="video-call-btn" class="call-control-btn" title="è§†é¢‘é€šè¯">ğŸ“¹</button>
    </div>
  </div>

  <script>
    // const { ipcRenderer } = require('electron');
    
    // å…¨å±€å˜é‡
    let currentSessionId = null;
    let sessions = [];
    let isVoiceEnabled = true; // æ–°å¢ï¼šè¯­éŸ³æ§åˆ¶å˜é‡

    const SERVER_URL = "https://121.43.116.49:5000";

    document.addEventListener('deviceready', () => {
      if (window.StatusBar) {
        StatusBar.overlaysWebView(false);
        StatusBar.backgroundColorByHexString('#ffffff'); // æ”¹æˆç™½è‰²æˆ–ä½ æƒ³è¦çš„é¢œè‰²
        StatusBar.styleDefault(); // æˆ–è€… StatusBar.styleLightContent()
      }
      
      // å¼ºåˆ¶éšè—ç³»ç»ŸUI
      if (window.AndroidFullScreen) {
        AndroidFullScreen.showSystemUI();
      }

      // æ–‡ä»¶ç³»ç»Ÿç›¸å…³ä»£ç 
      console.log(window.cordova.file.dataDirectory);

      initCallFeature();
    });

    // é‡é‡‡æ ·å‡½æ•°
    function downsampleBuffer(buffer, sampleRate, targetRate) {
      if (targetRate === sampleRate) return buffer;
      const sampleRateRatio = sampleRate / targetRate;
      const newLength = Math.round(buffer.length / sampleRateRatio);
      const result = new Float32Array(newLength);
      let offsetResult = 0;
      let offsetBuffer = 0;
      
      while (offsetResult < result.length) {
        const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
        let accum = 0, count = 0;
        for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
          accum += buffer[i];
          count++;
        }
        result[offsetResult] = accum / count;
        offsetResult++;
        offsetBuffer = nextOffsetBuffer;
      }
      return result;
    }

    // è½¬æ¢ä¸º16ä½PCM
    function floatTo16BitPCM(float32Array) {
      const buffer = new ArrayBuffer(float32Array.length * 2);
      const view = new DataView(buffer);
      let offset = 0;
      for (let i = 0; i < float32Array.length; i++, offset += 2) {
        let s = Math.max(-1, Math.min(1, float32Array[i]));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
      }
      return new Int16Array(buffer);
    }

    // åˆ›å»ºWAVæ–‡ä»¶
    function createWAVFile(audioData, sampleRate) {
      const length = audioData.length;
      const buffer = new ArrayBuffer(44 + length * 2);
      const view = new DataView(buffer);
      
      // WAVæ–‡ä»¶å¤´
      const writeString = (offset, string) => {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      };
      
      writeString(0, 'RIFF');
      view.setUint32(4, 36 + length * 2, true);
      writeString(8, 'WAVE');
      writeString(12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, 1, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * 2, true);
      view.setUint16(32, 2, true);
      view.setUint16(34, 16, true);
      writeString(36, 'data');
      view.setUint32(40, length * 2, true);
      
      // å†™å…¥éŸ³é¢‘æ•°æ®
      let offset = 44;
      for (let i = 0; i < audioData.length; i++) {
        view.setInt16(offset, audioData[i], true);
        offset += 2;
      }
      
      return buffer;
    }

    // ä¿å­˜éŸ³é¢‘æ–‡ä»¶åˆ°Cordovaæ–‡ä»¶ç³»ç»Ÿ
    async function saveAudioFile(wavBuffer) {
      return new Promise((resolve, reject) => {
        // ç¡®ä¿Cordova fileæ’ä»¶å¯ç”¨
        if (!window.cordova || !window.cordova.file) {
          reject(new Error('Cordova file plugin not available'));
          return;
        }

        window.resolveLocalFileSystemURL(cordova.file.dataDirectory, (dirEntry) => {
          // åˆ›å»ºchat_wavç›®å½•
          dirEntry.getDirectory('chat_wav', { create: true }, (chatWavDir) => {
            // åˆ›å»ºå½“å‰ä¼šè¯ç›®å½•
            chatWavDir.getDirectory(currentSessionId, { create: true }, (sessionDir) => {
              // ç”Ÿæˆæ–‡ä»¶å
              const fileName = `recording_${Date.now()}.wav`;
              
              // åˆ›å»ºæ–‡ä»¶
              sessionDir.getFile(fileName, { create: true }, (fileEntry) => {
                // å†™å…¥æ–‡ä»¶
                fileEntry.createWriter((fileWriter) => {
                  fileWriter.onwriteend = () => {
                    console.log('éŸ³é¢‘æ–‡ä»¶ä¿å­˜æˆåŠŸ:', fileEntry.nativeURL);
                    resolve(fileEntry.nativeURL);
                  };
                  
                  fileWriter.onerror = (e) => {
                    console.error('æ–‡ä»¶å†™å…¥å¤±è´¥:', e);
                    reject(e);
                  };
                  
                  // å°†ArrayBufferè½¬æ¢ä¸ºBlob
                  const blob = new Blob([wavBuffer], { type: 'audio/wav' });
                  fileWriter.write(blob);
                });
              }, reject);
            }, reject);
          }, reject);
        }, reject);
      });
    }

    // è°ƒç”¨ASR API
    async function performASR(audioFilePath) {
      try {
        console.log('Starting ASR with filePath:', audioFilePath);
        const audioFile = await readAudioFile(audioFilePath);
        
        if (!(audioFile instanceof Blob)) {
          throw new Error('Invalid audio file: not a Blob or File object');
        }

        const formData = new FormData();
        formData.append('audio', audioFile, 'recording.wav');
        console.log('FormData prepared, audioFile size:', audioFile.size, 'type:', audioFile.type);

        // è°ƒç”¨ASR API
        const response = await fetch(`${SERVER_URL}/asr`, {
          method: 'POST',
          body: formData
        });

        if (!response.ok) {
          throw new Error(`ASR API request failed: ${response.status}`);
        }

        const result = await response.json();

        if (!result.success) {
          throw new Error(result.error || 'ASR processing failed');
        }

        // æ ¹æ®APIè¿”å›æ ¼å¼è·å–è¯†åˆ«ç»“æœ
        return result.transcription || '';

      } catch (error) {
        console.error('ASRè°ƒç”¨å¤±è´¥:', error);
        return '';
      }
    }

    // è¯»å–éŸ³é¢‘æ–‡ä»¶ï¼ˆç”¨äºå‘é€åˆ°ASR APIï¼‰
    function readAudioFile(filePath) {
      return new Promise((resolve, reject) => {
        console.log('Resolving file system URL:', filePath);
        window.resolveLocalFileSystemURL(filePath, (fileEntry) => {
          console.log('File entry resolved:', fileEntry.name);
          fileEntry.file(
            (file) => {
              console.log('File loaded (raw):', {
                name: file.name,
                size: file.size,
                type: file.type,
                isFile: file instanceof File,
                isBlob: file instanceof Blob
              });

              // ä½¿ç”¨ FileReader è¯»å–æ–‡ä»¶å†…å®¹å¹¶åˆ›å»º Blob
              const reader = new FileReader();
              reader.onloadend = () => {
                const arrayBuffer = reader.result;
                const blob = new Blob([arrayBuffer], { type: file.type || 'audio/wav' });
                console.log('Converted to Blob:', {
                  size: blob.size,
                  type: blob.type,
                  isBlob: blob instanceof Blob
                });
                resolve(blob);
              };
              reader.onerror = (error) => {
                console.error('FileReader error:', error);
                reject(new Error('Failed to read file content: ' + error.message));
              };
              reader.readAsArrayBuffer(file);
            },
            (error) => {
              console.error('Failed to read file:', error);
              reject(new Error('Failed to read audio file: ' + error.message));
            }
          );
        }, (error) => {
          console.error('Invalid file path:', filePath, error);
          reject(new Error('Invalid file path: ' + error.message));
        });
      });
    }

    // AIé€šè¯éƒ¨åˆ† - ä¼˜åŒ–ç‰ˆæœ¬
    function initCallFeature() {
      // å…¨å±€å˜é‡æ¥ç®¡ç†è®¡æ—¶å™¨
      let callTimerInterval;
      let callStartTime;

      const callPage = document.getElementById('call-page');
      const endCallBtn = document.getElementById('end-call-btn');
      const videoCallBtn = document.getElementById('video-call-btn');
      
      // ç»“æŸé€šè¯
      endCallBtn.addEventListener('click', () => {
        exitCallPage();
        window.location.href = 'index.html';
      });
      
      videoCallBtn.addEventListener('click', () => {
        // åœæ­¢å½“å‰çš„è¯­éŸ³é€šè¯ï¼ˆå¦‚æœæ­£åœ¨è¿›è¡Œï¼‰
        exitCallPage();
        // å¯¼èˆªåˆ°è§†é¢‘é€šè¯é¡µé¢
        window.location.href = 'video_call.html';
      });
      enterCallPage();
    }

    function enterCallPage() {
      const callPage = document.getElementById('call-page');
      const callAvatar = document.getElementById('call-avatar');
      const callTimer = document.getElementById('call-timer');
      
      // è¿™é‡Œè®¾ç½®AIå¥³å‹çš„å¤´åƒå›¾ç‰‡è·¯å¾„
      callAvatar.src = './img/icon.png';
      
      callPage.style.display = 'flex';
      
      // æ·»åŠ è¿›å…¥åŠ¨ç”»
      callPage.style.opacity = '0';
      callPage.style.transform = 'scale(0.9)';
      setTimeout(() => {
        callPage.style.transition = 'all 0.3s ease';
        callPage.style.opacity = '1';
        callPage.style.transform = 'scale(1)';
      }, 10);

      // å¯åŠ¨è®¡æ—¶å™¨
      callStartTime = Date.now();
      callTimer.textContent = '00:00';
      callTimerInterval = setInterval(() => {
        const elapsedTime = Date.now() - callStartTime;
        const seconds = Math.floor(elapsedTime / 1000) % 60;
        const minutes = Math.floor(elapsedTime / 1000 / 60);
        
        const formattedTime = 
          `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        
        callTimer.textContent = formattedTime;
      }, 1000);

      // å¯åŠ¨å½•éŸ³å’Œé€šè¯é€»è¾‘
      startCallConversation();
    }

    function exitCallPage() {
      const callPage = document.getElementById('call-page');
      const callTimer = document.getElementById('call-timer');

      // åœæ­¢å½•éŸ³å’Œé€šè¯é€»è¾‘
      stopCallConversation();

      // åœæ­¢è®¡æ—¶å™¨
      if (callTimerInterval) {
        clearInterval(callTimerInterval);
        callTimerInterval = null;
      }
      callTimer.textContent = '00:00';
      
      // æ·»åŠ é€€å‡ºåŠ¨ç”»
      callPage.style.transition = 'all 0.3s ease';
      callPage.style.opacity = '0';
      callPage.style.transform = 'scale(0.9)';
      
      setTimeout(() => {
        callPage.style.display = 'none';
        callPage.style.transition = '';
      }, 300);
    }

    // ========== é€šè¯çŠ¶æ€ç®¡ç† ==========
    class CallManager {
      constructor() {
        this.isCallActive = false;
        this.isProcessing = false;
        this.mediaRecorder = null;
        this.audioStream = null;
        this.audioContext = null;
        this.vadCheckInterval = null;
        this.silenceTimer = null;
        this.audioChunks = [];
        this.conversationHistory = [];
        this.analyser = null;
        this.hasDetectedSpeech = false; // æ–°å¢ï¼šæ ‡è®°æ˜¯å¦æ£€æµ‹åˆ°è¿‡è¯­éŸ³
        
        // é…ç½®å‚æ•°
        this.SILENCE_THRESHOLD = -20; // é™éŸ³é˜ˆå€¼ï¼ˆåˆ†è´ï¼‰
        this.SILENCE_DURATION = 50; // é™éŸ³æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
        this.SPEECH_THRESHOLD = -15; // è¯­éŸ³æ£€æµ‹é˜ˆå€¼ï¼ˆåˆ†è´ï¼‰
      }

      // é‡ç½®æ‰€æœ‰çŠ¶æ€
      reset() {
        this.isCallActive = false;
        this.isProcessing = false;
        this.hasDetectedSpeech = false;
        this.audioChunks = [];
        this.conversationHistory = [];
        
        // æ¸…ç†å®šæ—¶å™¨
        if (this.vadCheckInterval) {
          clearInterval(this.vadCheckInterval);
          this.vadCheckInterval = null;
        }
        if (this.silenceTimer) {
          clearTimeout(this.silenceTimer);
          this.silenceTimer = null;
        }
        
        // åœæ­¢å½•éŸ³
        if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
          this.mediaRecorder.stop();
        }
        this.mediaRecorder = null;
        
        // å…³é—­éŸ³é¢‘æµ
        if (this.audioStream) {
          this.audioStream.getTracks().forEach(track => track.stop());
          this.audioStream = null;
        }
        
        // å…³é—­éŸ³é¢‘ä¸Šä¸‹æ–‡
        if (this.audioContext && this.audioContext.state !== 'closed') {
          this.audioContext.close();
          this.audioContext = null;
        }
        
        this.analyser = null;
      }

      // æ£€æŸ¥é€šè¯æ˜¯å¦å¤„äºæ´»åŠ¨çŠ¶æ€
      isActive() {
        return this.isCallActive;
      }

      // å¼€å§‹é€šè¯
      async start() {
        if (this.isCallActive) {
          console.warn('é€šè¯å·²ç»åœ¨è¿›è¡Œä¸­');
          return;
        }

        this.reset(); // ç¡®ä¿çŠ¶æ€å¹²å‡€
        this.isCallActive = true;
        
        const callStatus = document.getElementById('call-status');
        const callMessagesContainer = document.getElementById('call-messages-container');

        // æ¸…ç©ºä¹‹å‰çš„å¯¹è¯
        callMessagesContainer.innerHTML = '';

        try {
          // this.audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          this.audioStream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            sampleRate: 16000,
            channelCount: 1,
            echoCancellation: true,
            noiseSuppression: true
          }
        });
          await this.initializeAudioProcessing();
          this.startListening();
        } catch (error) {
          console.error('è·å–éº¦å…‹é£å¤±è´¥:', error);
          alert('æ— æ³•å¯ç”¨éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®ã€‚');
          this.reset();
          exitCallPage();
        }
      }

      // åœæ­¢é€šè¯
      stop() {
        console.log('åœæ­¢é€šè¯');
        this.reset();
        
        const callStatus = document.getElementById('call-status');
        callStatus.style.display = 'none';
      }

      // åˆå§‹åŒ–éŸ³é¢‘å¤„ç†
      async initializeAudioProcessing() {
        // this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
          sampleRate: 16000
        });
        
        // è®¾ç½®éŸ³é¢‘åˆ†æ
        const source = this.audioContext.createMediaStreamSource(this.audioStream);
        this.analyser = this.audioContext.createAnalyser();
        this.analyser.fftSize = 256;
        source.connect(this.analyser);
      }

      // å¼€å§‹ç›‘å¬
      startListening() {
        if (!this.isCallActive || this.isProcessing) {
          return;
        }

        console.log('å¼€å§‹ç›‘å¬...');
        const callStatus = document.getElementById('call-status');
        
        // é‡ç½®çŠ¶æ€
        this.audioChunks = [];
        this.hasDetectedSpeech = false;

        // è®¾ç½®å½•éŸ³å™¨é€‰é¡¹
        // è®¾ç½®MediaRecorder
        const options = {
          mimeType: 'audio/webm;codecs=opus'
        };
        
        // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒçš„æ ¼å¼
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
          options.mimeType = 'audio/webm';
          if (!MediaRecorder.isTypeSupported(options.mimeType)) {
            options.mimeType = 'audio/mp4';
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
              delete options.mimeType;
            }
          }
        }

        this.mediaRecorder = new MediaRecorder(this.audioStream, options);

        this.mediaRecorder.ondataavailable = event => {
          if (this.isCallActive && event.data && event.data.size > 0) {
            console.log(`æ”¶åˆ°éŸ³é¢‘æ•°æ®å—: ${event.data.size} bytes`);
            this.audioChunks.push(event.data);
          }
        };

        this.mediaRecorder.onstart = () => {
          if (!this.isCallActive) return;
          console.log('å½•éŸ³å¼€å§‹...');
          callStatus.textContent = 'ç­‰å¾…è¯­éŸ³è¾“å…¥...';
          callStatus.style.display = 'block';
        };

        this.mediaRecorder.onstop = async () => {
          if (!this.isCallActive) return;
          console.log('å½•éŸ³ç»“æŸ');
          
          // åªæœ‰å½“æ£€æµ‹åˆ°è¯­éŸ³ä¸”æœ‰éŸ³é¢‘æ•°æ®æ—¶æ‰å¤„ç†
          if (this.hasDetectedSpeech && this.audioChunks.length > 0) {
            const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
            const audioFile = new File([audioBlob], "recording.wav", { type: "audio/wav" });
            
            if (audioFile.size > -1) { // ç¡®ä¿éŸ³é¢‘æ–‡ä»¶ä¸ä¸ºç©ºï¼ˆè‡³å°‘1KBï¼‰
              console.log('æ£€æµ‹åˆ°æœ‰æ•ˆè¯­éŸ³ï¼Œå¼€å§‹å¤„ç†...');
              await this.processAudio();
            } else {
              console.log('éŸ³é¢‘æ–‡ä»¶å¤ªå°ï¼Œè·³è¿‡å¤„ç†');
              this.restartListening();
            }
          } else {
            console.log('æœªæ£€æµ‹åˆ°è¯­éŸ³æˆ–æ— éŸ³é¢‘æ•°æ®ï¼Œé‡æ–°å¼€å§‹ç›‘å¬');
            this.restartListening();
          }
        };

        // å¯åŠ¨å½•éŸ³
        this.mediaRecorder.start();
        
        // å¯åŠ¨è¯­éŸ³æ´»åŠ¨æ£€æµ‹
        this.startVAD();
      }

      // å¯åŠ¨è¯­éŸ³æ´»åŠ¨æ£€æµ‹ï¼ˆVADï¼‰
      startVAD() {
        if (!this.analyser || !this.isCallActive) {
          return;
        }

        const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
        const callStatus = document.getElementById('call-status');

        const checkAudio = () => {
          if (!this.isCallActive || !this.mediaRecorder || 
              this.mediaRecorder.state !== 'recording' || this.isProcessing) {
            return;
          }

          this.analyser.getByteFrequencyData(dataArray);
          let sum = dataArray.reduce((a, b) => a + b, 0);
          let average = sum / dataArray.length;
          let decibels = 20 * Math.log10(average / 255);

          // æ£€æµ‹åˆ°è¯­éŸ³ï¼ˆéŸ³é‡é«˜äºè¯­éŸ³é˜ˆå€¼ï¼‰
          if (decibels > this.SPEECH_THRESHOLD) {
            if (!this.hasDetectedSpeech) {
              console.log(`æ£€æµ‹åˆ°è¯­éŸ³å¼€å§‹: ${decibels.toFixed(2)} dB`);
              this.hasDetectedSpeech = true;
              callStatus.textContent = 'æ­£åœ¨è†å¬...';
            }
            
            // æ¸…é™¤é™éŸ³è®¡æ—¶å™¨
            if (this.silenceTimer) {
              clearTimeout(this.silenceTimer);
              this.silenceTimer = null;
            }
          } 
          // æ£€æµ‹åˆ°é™éŸ³ï¼ˆéŸ³é‡ä½äºé™éŸ³é˜ˆå€¼ï¼‰ä¸”ä¹‹å‰æ£€æµ‹åˆ°è¿‡è¯­éŸ³
          else if (decibels < this.SILENCE_THRESHOLD && this.hasDetectedSpeech) {
            if (!this.silenceTimer) {
              console.log(`æ£€æµ‹åˆ°é™éŸ³å¼€å§‹: ${decibels.toFixed(2)} dB`);
              this.silenceTimer = setTimeout(() => {
                console.log('é™éŸ³æŒç»­è¶³å¤Ÿé•¿æ—¶é—´ï¼Œç»“æŸå½•éŸ³');
                this.finishRecording();
              }, this.SILENCE_DURATION);
            }
          }
        };

        // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
        if (this.vadCheckInterval) {
          clearInterval(this.vadCheckInterval);
        }
        
        // æ¯100æ¯«ç§’æ£€æŸ¥ä¸€æ¬¡
        this.vadCheckInterval = setInterval(checkAudio, 100);
      }

      // ç»“æŸå½“å‰å½•éŸ³
      finishRecording() {
        if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
          console.log('åœæ­¢å½•éŸ³...');
          this.mediaRecorder.stop();
        }
        
        // æ¸…ç†VAD
        if (this.vadCheckInterval) {
          clearInterval(this.vadCheckInterval);
          this.vadCheckInterval = null;
        }
        if (this.silenceTimer) {
          clearTimeout(this.silenceTimer);
          this.silenceTimer = null;
        }
      }

      // é‡æ–°å¼€å§‹ç›‘å¬
      restartListening() {
        if (!this.isCallActive) return;
        
        setTimeout(() => {
          if (this.isCallActive && !this.isProcessing) {
            this.startListening();
          }
        }, 500);
      }

      // å¤„ç†éŸ³é¢‘
      async processAudio() {
        if (!this.isCallActive) return;
        
        this.isProcessing = true;
        const callStatus = document.getElementById('call-status');

        try {
          // 1. ä¿å­˜éŸ³é¢‘æ–‡ä»¶åˆ°æœ¬åœ°
          callStatus.textContent = 'æ­£åœ¨å¤„ç†å½•éŸ³...';

          // åˆ›å»ºéŸ³é¢‘blob
          const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
          
          // è½¬æ¢ä¸ºArrayBuffer
          const arrayBuffer = await audioBlob.arrayBuffer();
          
          // è§£ç éŸ³é¢‘æ•°æ®
          const audioBufferObj = await this.audioContext.decodeAudioData(arrayBuffer);
          
          // ç¡®ä¿æ˜¯16kHzå•å£°é“
          const targetSampleRate = 16000;
          let audioData = audioBufferObj.getChannelData(0);
          
          // å¦‚æœé‡‡æ ·ç‡ä¸æ˜¯16kHzï¼Œè¿›è¡Œé‡é‡‡æ ·
          if (audioBufferObj.sampleRate !== targetSampleRate) {
            audioData = downsampleBuffer(audioData, audioBufferObj.sampleRate, targetSampleRate);
          }
          
          // è½¬æ¢ä¸º16ä½PCM
          const int16Data = floatTo16BitPCM(audioData);
          
          // åˆ›å»ºWAVæ–‡ä»¶
          const wavBuffer = createWAVFile(int16Data, targetSampleRate);

          const audioFilePath = await this.saveAudioFile(wavBuffer);

          // 2. ASR (è¯­éŸ³è¯†åˆ«)
          callStatus.textContent = 'æ­£åœ¨è¯†åˆ«...';

          const asrResult =await performASR(audioFilePath)
          
          if (!this.isCallActive) return; // æ£€æŸ¥çŠ¶æ€
          
          if (asrResult && asrResult.trim()) {
            console.log('è¯†åˆ«ç»“æœ:', asrResult);
            this.displayMessage(asrResult, 'user');

            // 2. LLM (å¤§æ¨¡å‹)
            callStatus.textContent = 'æ€è€ƒä¸­...';
            const llmResponse = await this.getLlmResponse(asrResult);
            
            if (!this.isCallActive) return; // æ£€æŸ¥çŠ¶æ€
            
            if (llmResponse && llmResponse.trim()) {
              // 3. TTS (æ–‡æœ¬è½¬è¯­éŸ³)
              const audioBlob = await this.getTtsAudio(llmResponse);
              
              if (!this.isCallActive) return; // æ£€æŸ¥çŠ¶æ€
              
              if (audioBlob) {
                console.log('AI å›å¤:', llmResponse);
                this.displayMessage(llmResponse, 'bot');

                callStatus.textContent = 'æ’­æ”¾ä¸­...';
                await this.playAudioFromBlob(audioBlob);
              }
            }
          } else {
            console.log('æ²¡æœ‰è¯†åˆ«åˆ°æœ‰æ•ˆå†…å®¹');
          }
          
        } catch (error) {
          console.error('å¤„ç†éŸ³é¢‘æ—¶å‡ºé”™:', error);
        } finally {
          if (this.isCallActive) {
            this.isProcessing = false;
            callStatus.style.display = 'none';
            this.restartListening();
          }
        }
      }

      // ä¿å­˜éŸ³é¢‘æ–‡ä»¶åˆ°Cordovaæ–‡ä»¶ç³»ç»Ÿ
      async saveAudioFile(wavBuffer) {
        return new Promise((resolve, reject) => {
          if (!window.cordova || !window.cordova.file) {
              reject(new Error('Cordova file plugin not available'));
              return;
          }

          window.resolveLocalFileSystemURL(cordova.file.dataDirectory, (dirEntry) => {
            dirEntry.getDirectory('audio_temp', { create: true }, (chatWavDir) => {
              const fileName = `recording.wav`;
              // åˆ›å»ºæ–‡ä»¶
              chatWavDir.getFile(fileName, { create: true }, (fileEntry) => {
                // å†™å…¥æ–‡ä»¶
                fileEntry.createWriter((fileWriter) => {
                  fileWriter.onwriteend = () => {
                    console.log('éŸ³é¢‘æ–‡ä»¶ä¿å­˜æˆåŠŸ:', fileEntry.nativeURL);
                    resolve(fileEntry.nativeURL);
                  };
                  
                  fileWriter.onerror = (e) => {
                    console.error('æ–‡ä»¶å†™å…¥å¤±è´¥:', e);
                    reject(e);
                  };
                  
                  // å°†ArrayBufferè½¬æ¢ä¸ºBlob
                  const blob = new Blob([wavBuffer], { type: 'audio/wav' });
                  fileWriter.write(blob);
                });
              }, reject);
            }, reject);
          }, reject);
        });
      }

      // æ˜¾ç¤ºæ¶ˆæ¯
      displayMessage(text, role) {
        const container = document.getElementById('call-messages-container');
        const messageEl = document.createElement('div');
        messageEl.className = `call-message ${role}`;
        if(role == 'user') messageEl.textContent = 'æˆ‘ï¼š'+text;
        else messageEl.textContent = '02ï¼š'+text;  // textContentä¼šè‡ªåŠ¨å¤„ç†\næ¢è¡Œ
        container.appendChild(messageEl);

        // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
        container.scrollTop = container.scrollHeight;

        // 7ç§’åæ·¡å‡ºæ¶ˆå¤±
        setTimeout(() => {
          messageEl.classList.add('fade-out');
          setTimeout(() => {
            if (container.contains(messageEl)) {
              container.removeChild(messageEl);
            }
          }, 500);
        }, 60000);
      }

      async getLlmResponse(text) {
        if (!this.isCallActive) return null;
        
        this.conversationHistory.push({ role: 'user', content: text });
        try {
          const response = await fetch(`${SERVER_URL}/chat`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message: text, history: this.conversationHistory })
          });
          const data = await response.json();
          if (data.success) {
            this.conversationHistory.push({ role: 'assistant', content: data.response });
            return data.response;
          }
          return null;
        } catch (error) {
          console.error('LLM è¯·æ±‚å¤±è´¥:', error);
          return null;
        }
      }

      async getTtsAudio(text) {
        if (!this.isCallActive) {
          console.log('é€šè¯å·²åœæ­¢ï¼Œå–æ¶ˆTTSè¯·æ±‚');
          return null;
        }

        try {
          const response = await fetch(`${SERVER_URL}/tts`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text: text })
          });
          return await response.blob();
        } catch (error) {
          console.error('TTS è¯·æ±‚å¤±è´¥:', error);
          return null;
        }
      }

      async playAudioFromBlob(audioBlob) {
        if (!this.isCallActive) return;
        
        const audioUrl = URL.createObjectURL(audioBlob);
        const audio = new Audio(audioUrl);
        
        return new Promise(resolve => {
          audio.onended = () => {
            URL.revokeObjectURL(audioUrl);
            resolve();
          };
          audio.onerror = () => {
            console.error('éŸ³é¢‘æ’­æ”¾å¤±è´¥');
            URL.revokeObjectURL(audioUrl);
            resolve();
          };
          
          // æ£€æŸ¥é€šè¯çŠ¶æ€
          if (this.isCallActive) {
            audio.play();
          } else {
            URL.revokeObjectURL(audioUrl);
            resolve();
          }
        });
      }
    }

    // ========== å…¨å±€å®ä¾‹ ==========
    const callManager = new CallManager();

    // ========== å¯¼å‡ºçš„å‡½æ•° ==========
    async function startCallConversation() {
      await callManager.start();
    }

    function stopCallConversation() {
      callManager.stop();
    }
  </script>
</body>
</html>