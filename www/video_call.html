<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <title>AI è§†é¢‘é€šè¯</title>
    <style>
        html, body {
            overflow: hidden;
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh; /* æ”¹ä¸ºè§†å£é«˜åº¦ */
            background: #000;
            /* æ·»åŠ ä»¥ä¸‹å±æ€§ç¡®ä¿å…¨å± */
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        #main-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            /* æ·»åŠ ä»¥ä¸‹å±æ€§ */
            position: fixed;
            top: 0;
            left: 0;
            z-index: 0;
        }
        
        #camera-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #cameraVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* åå‘é•œåƒï¼ŒæŠµæ¶ˆæ‘„åƒå¤´çš„é»˜è®¤é•œåƒæ•ˆæœ */
            -webkit-transform: scaleX(-1); /* å…¼å®¹æ€§ */
        }
        
        #live2d-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        
        #live2d-container canvas {
            width: 100% !important;
            height: 100% !important;
            pointer-events: auto;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 3;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-button {
            padding: 12px 18px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #end-call-btn { background: #f44336; }
        #end-call-btn:hover { background: #d32f2f; }

        #error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            display: none;
            z-index: 10;
            text-align: center;
        }

        /* æ·»åŠ åˆ°ç°æœ‰CSSä¸­ */
        #call-messages-container {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 300px;
            height: 60%;
            overflow-y: auto;
            z-index: 4;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 20px 0;
        }

        .call-message {
            padding: 12px 16px;
            border-radius: 12px;
            max-width: 100%;
            word-wrap: break-word;
            font-size: 14px;
            line-height: 1.4;
            opacity: 1;
            transition: opacity 0.5s ease-out;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .call-message.user {
            background: rgba(255, 152, 0, 0.9); /* æ©™è‰² */
            color: white;
            align-self: flex-end;
            margin-left: 60px;
        }

        .call-message.bot {
            background: rgba(33, 150, 243, 0.9); /* è“è‰² */
            color: white;
            align-self: flex-end;
            margin-left: 60px;
        }

        .call-message.fade-out {
            opacity: 0;
        }

        /* æ»šåŠ¨æ¡æ ·å¼ */
        #call-messages-container::-webkit-scrollbar {
            width: 4px;
        }

        #call-messages-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }

        #call-messages-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }

        /* ç¼©æ”¾æŒ‰é’®å®¹å™¨ */
        #zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 5;
            display: flex;
            flex-direction: row;
            gap: 2px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 25px;
            padding: 5px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .zoom-button {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .zoom-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .zoom-button:active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
        }

        .zoom-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .zoom-button:disabled:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: none;
        }

        /* ç¼©æ”¾çº§åˆ«æŒ‡ç¤ºå™¨ */
        #zoom-level-indicator {
            position: absolute;
            bottom: 80px;
            right: 20px;
            z-index: 5;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 8px 15px;
            border-radius: 15px;
            font-size: 14px;
            font-weight: bold;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
    </style>
    <!-- Live2DCubismCore script -->
    <script src="./Core/live2dcubismcore.js"></script>
    <!-- Build script -->
    <script type="module" crossorigin src="/assets/index-BdKM-sSx.js"></script>
    <script src="cordova.js"></script>
</head>
<body>
    <div id="main-container">
        <div id="camera-background">
            <video id="cameraVideo" autoplay playsinline muted></video>
        </div>
        <div id="live2d-container"></div>
        <div id="controls">
            <button id="switchCameraBtn" class="control-button">ğŸ”„ åˆ‡æ¢æ‘„åƒå¤´</button>
            <button id="backToVoiceBtn" class="control-button">ğŸ’¬ è¿”å›è¯­éŸ³</button>
            <button id="endCallBtn" class="control-button">ğŸ“ ç»“æŸé€šè¯</button>
        </div>
        <div id="zoom-controls">
            <button id="zoom-out-btn" class="zoom-button">-</button>
            <button id="zoom-in-btn" class="zoom-button">+</button>
        </div>
        <div id="zoom-level-indicator">1.0x</div>
        <div id="error-message"></div>
    </div>

    <!-- é€šè¯é¡µé¢ -->
    <div id="call-page">
        <div id="call-avatar-container">
            <p id="call-timer" style="
                color: white;
                font-size: 20px;
                font-weight: bold;
                margin-top: 10px;">00:00</p>
            <p id="call-status" style="
                color: #4CAF50; 
                font-weight: bold; 
                margin-top: 5px; 
                display: none;">è†å¬ä¸­</p>
            <div id="call-messages-container"></div>
        </div>
    </div>
    
    <script>

        const SERVER_URL = "https://121.43.116.49:5000";

        document.addEventListener('DOMContentLoaded', () => {
            // è§‚å¯Ÿ canvas å…ƒç´ çš„æ·»åŠ 
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    mutation.addedNodes.forEach((node) => {
                        if (node.tagName === 'CANVAS') {
                            const container = document.getElementById('live2d-container');
                            if (container && node.parentElement === document.body) {
                                container.appendChild(node);
                                node.style.width = '100%';
                                node.style.height = '100%';
                            }
                        }
                    });
                });
            });
            
            observer.observe(document.body, { childList: true });
        });

        // ç­‰å¾… Cordova è®¾å¤‡å°±ç»ª
        // document.addEventListener('deviceready', initializeCamera, false);

        document.addEventListener('deviceready', () => {
            // åŸæœ‰çš„çŠ¶æ€æ ä»£ç 
            if (window.StatusBar) {
                StatusBar.overlaysWebView(true); // æ”¹ä¸ºtrueï¼Œè®©å†…å®¹è¦†ç›–çŠ¶æ€æ 
                StatusBar.hide(); // éšè—çŠ¶æ€æ 
            }
            
            // å¼ºåˆ¶å…¨å±æ˜¾ç¤º
            if (window.AndroidFullScreen) {
                AndroidFullScreen.immersiveMode(); // æ”¹ä¸ºæ²‰æµ¸å¼æ¨¡å¼
            }
            
            // æ·»åŠ å…ƒæ ‡ç­¾è®¾ç½®è§†å£
            const viewport = document.querySelector('meta[name="viewport"]');
            if (viewport) {
                viewport.setAttribute('content', 'width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no');
            }

            // æ–‡ä»¶ç³»ç»Ÿç›¸å…³ä»£ç 
            console.log(window.cordova.file.dataDirectory);
            
            initializeCamera();

            startCallConversation();
        });
        
        // å¦‚æœä¸æ˜¯ Cordova ç¯å¢ƒï¼Œç›´æ¥åˆå§‹åŒ–
        if (!window.cordova) {
            document.addEventListener('DOMContentLoaded', initializeCamera);
        }

        function initializeCamera() {
            const videoElement = document.getElementById('cameraVideo');
            const errorMessage = document.getElementById('error-message');
            let currentStream = null;
            let cameraDevices = [];
            let currentCameraIndex = 0;

            let currentZoomScale = 1.0;
            const minZoomScale = 1.0;
            const maxZoomScale = 5.0;
            const zoomStep = 0.2; // æ¯æ¬¡ç¼©æ”¾çš„æ­¥é•¿

            // åº”ç”¨ç¼©æ”¾å˜æ¢
            function applyZoomTransform() {
                const videoElement = document.getElementById('cameraVideo');
                const isFrontCamera = cameraDevices.length > 1 ? currentCameraIndex === 0 : true;
                
                // ä¿æŒå‰ç½®æ‘„åƒå¤´çš„é•œåƒæ•ˆæœ
                if (isFrontCamera) {
                    videoElement.style.transform = `scaleX(-${currentZoomScale}) scaleY(${currentZoomScale})`;
                    videoElement.style.webkitTransform = `scaleX(-${currentZoomScale}) scaleY(${currentZoomScale})`;
                } else {
                    videoElement.style.transform = `scale(${currentZoomScale})`;
                    videoElement.style.webkitTransform = `scale(${currentZoomScale})`;
                }
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                updateZoomButtons();
                
                // æ˜¾ç¤ºç¼©æ”¾çº§åˆ«
                showZoomLevel();
                
                console.log(`åº”ç”¨ç¼©æ”¾: ${currentZoomScale.toFixed(1)}x`);
            }

            // æ›´æ–°ç¼©æ”¾æŒ‰é’®çŠ¶æ€
            function updateZoomButtons() {
                const zoomInBtn = document.getElementById('zoom-in-btn');
                const zoomOutBtn = document.getElementById('zoom-out-btn');
                
                // æ›´æ–°æŒ‰é’®å¯ç”¨çŠ¶æ€
                zoomInBtn.disabled = currentZoomScale >= maxZoomScale;
                zoomOutBtn.disabled = currentZoomScale <= minZoomScale;
            }

            // æ˜¾ç¤ºç¼©æ”¾çº§åˆ«
            function showZoomLevel() {
                const indicator = document.getElementById('zoom-level-indicator');
                indicator.textContent = `${currentZoomScale.toFixed(1)}x`;
                indicator.style.opacity = '1';
                
                // 2ç§’åéšè—
                setTimeout(() => {
                    indicator.style.opacity = '0';
                }, 2000);
            }

            // æ”¾å¤§åŠŸèƒ½
            function zoomIn() {
                if (currentZoomScale < maxZoomScale) {
                    currentZoomScale = Math.min(maxZoomScale, currentZoomScale + zoomStep);
                    applyZoomTransform();
                }
            }

            // ç¼©å°åŠŸèƒ½  
            function zoomOut() {
                if (currentZoomScale > minZoomScale) {
                    currentZoomScale = Math.max(minZoomScale, currentZoomScale - zoomStep);
                    applyZoomTransform();
                }
            }

            // é‡ç½®ç¼©æ”¾
            function resetZoom() {
                currentZoomScale = minZoomScale;
                applyZoomTransform();
            }

            // ç»‘å®šæŒ‰é’®äº‹ä»¶ï¼ˆåœ¨ initializeCamera å‡½æ•°çš„æœ€åæ·»åŠ ï¼‰
            function initZoomControls() {
                const zoomInBtn = document.getElementById('zoom-in-btn');
                const zoomOutBtn = document.getElementById('zoom-out-btn');
                
                // ç»‘å®šç‚¹å‡»äº‹ä»¶
                zoomInBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    zoomIn();
                });
                
                zoomOutBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    zoomOut();
                });
                
                // ç»‘å®šé•¿æŒ‰äº‹ä»¶ï¼ˆè¿ç»­ç¼©æ”¾ï¼‰
                let zoomInterval;
                
                // æ”¾å¤§æŒ‰é’®é•¿æŒ‰
                zoomInBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    zoomInterval = setInterval(() => {
                        if (currentZoomScale < maxZoomScale) {
                            zoomIn();
                        } else {
                            clearInterval(zoomInterval);
                        }
                    }, 150);
                });
                
                zoomInBtn.addEventListener('touchend', () => {
                    clearInterval(zoomInterval);
                });
                
                zoomInBtn.addEventListener('touchcancel', () => {
                    clearInterval(zoomInterval);
                });
                
                // ç¼©å°æŒ‰é’®é•¿æŒ‰
                zoomOutBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    zoomInterval = setInterval(() => {
                        if (currentZoomScale > minZoomScale) {
                            zoomOut();
                        } else {
                            clearInterval(zoomInterval);
                        }
                    }, 150);
                });
                
                zoomOutBtn.addEventListener('touchend', () => {
                    clearInterval(zoomInterval);
                });
                
                zoomOutBtn.addEventListener('touchcancel', () => {
                    clearInterval(zoomInterval);
                });
                
                // åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€
                updateZoomButtons();
                
                console.log('ç¼©æ”¾æ§ä»¶å·²åˆå§‹åŒ–');
            }

            // æ˜¾ç¤ºæƒé™å¼•å¯¼
            function showPermissionGuide() {
                const guide = `
                    <h3>ğŸ“· éœ€è¦æ‘„åƒå¤´æƒé™</h3>
                    <div class="permission-guide">
                        <p><strong>è¯·æŒ‰ä»¥ä¸‹æ­¥éª¤å¼€å¯æƒé™ï¼š</strong></p>
                        <p>1. ç‚¹å‡»"æ‰“å¼€åº”ç”¨è®¾ç½®"æŒ‰é’®</p>
                        <p>2. æ‰¾åˆ°"æƒé™"æˆ–"åº”ç”¨æƒé™"</p>
                        <p>3. æ‰¾åˆ°"æ‘„åƒå¤´"æˆ–"ç›¸æœº"æƒé™</p>
                        <p>4. ç‚¹å‡»å¼€å¯æƒé™</p>
                        <p>5. è¿”å›åº”ç”¨å¹¶ç‚¹å‡»"é‡è¯•"</p>
                    </div>
                    <button onclick="openAppSettings()">æ‰“å¼€åº”ç”¨è®¾ç½®</button>
                    <button onclick="retryCamera()">é‡è¯•</button>
                    <button onclick="closeError()">å…³é—­</button>
                `;
                
                errorMessage.innerHTML = guide;
                errorMessage.style.display = 'block';
            }

            // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
            function showError(message) {
                console.error(message);
                if (message.includes('æƒé™')) {
                    showPermissionGuide();
                } else {
                    errorMessage.innerHTML = `<h3>âŒ é”™è¯¯</h3><p>${message}</p><button onclick="closeError()">å…³é—­</button>`;
                    errorMessage.style.display = 'block';
                }
            }

            // å…¨å±€å‡½æ•°ï¼šæ‰“å¼€åº”ç”¨è®¾ç½®
            window.openAppSettings = function() {
                if (window.cordova && cordova.plugins && cordova.plugins.settings) {
                    cordova.plugins.settings.open(['application_details', 'application'], 
                        () => console.log('è®¾ç½®é¡µé¢å·²æ‰“å¼€'),
                        () => console.log('æ— æ³•æ‰“å¼€è®¾ç½®é¡µé¢')
                    );
                } else if (window.plugins && window.plugins.intentShim) {
                    // å¤‡ç”¨æ–¹æ³•ï¼šä½¿ç”¨ intent
                    window.plugins.intentShim.startActivity({
                        action: 'android.settings.APPLICATION_DETAILS_SETTINGS',
                        uri: 'package:' + cordova.getAppVersion.getPackageName()
                    });
                } else {
                    alert('è¯·æ‰‹åŠ¨è¿›å…¥æ‰‹æœºè®¾ç½® â†’ åº”ç”¨ç®¡ç† â†’ æ‰¾åˆ°æœ¬åº”ç”¨ â†’ æƒé™ç®¡ç† â†’ å¼€å¯æ‘„åƒå¤´æƒé™');
                }
            };

            // å…¨å±€å‡½æ•°ï¼šé‡è¯•æ‘„åƒå¤´
            window.retryCamera = function() {
                closeError();
                startCamera();
            };

            // å…¨å±€å‡½æ•°ï¼šå…³é—­é”™è¯¯æç¤º
            window.closeError = function() {
                errorMessage.style.display = 'none';
            };

            // è¯·æ±‚æƒé™ï¼ˆCordova ç¯å¢ƒï¼‰
            async function requestCameraPermission() {
                return new Promise((resolve) => {
                    if (window.cordova && cordova.plugins && cordova.plugins.permissions) {
                        const permissions = cordova.plugins.permissions;
                        permissions.checkPermission(
                            permissions.CAMERA,
                            (status) => {
                                if (status.hasPermission) {
                                    console.log('æ‘„åƒå¤´æƒé™å·²è·å¾—');
                                    resolve(true);
                                } else {
                                    permissions.requestPermission(
                                        permissions.CAMERA,
                                        (result) => {
                                            console.log('æƒé™è¯·æ±‚ç»“æœ:', result.hasPermission);
                                            resolve(result.hasPermission);
                                        },
                                        () => {
                                            console.error('æƒé™è¯·æ±‚å¤±è´¥');
                                            resolve(false);
                                        }
                                    );
                                }
                            },
                            () => {
                                console.error('æ£€æŸ¥æƒé™å¤±è´¥');
                                resolve(false);
                            }
                        );
                    } else {
                        // é Cordova ç¯å¢ƒæˆ–æƒé™æ’ä»¶ä¸å­˜åœ¨
                        resolve(true);
                    }
                });
            }

            // è·å–æ‘„åƒå¤´è®¾å¤‡
            async function getCameraDevices() {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    cameraDevices = devices.filter(device => device.kind === 'videoinput');
                    console.log(`å‘ç° ${cameraDevices.length} ä¸ªæ‘„åƒå¤´è®¾å¤‡`);
                    return cameraDevices.length > 0;
                } catch (error) {
                    console.error('è·å–æ‘„åƒå¤´è®¾å¤‡å¤±è´¥:', error);
                    showError('æ— æ³•è·å–æ‘„åƒå¤´è®¾å¤‡åˆ—è¡¨');
                    return false;
                }
            }

            // å¯åŠ¨æ‘„åƒå¤´
            // ä¿®æ”¹åçš„ startCamera å‡½æ•°
            async function startCamera() {
                try {
                    console.log('ğŸ”„ å°è¯•å¯åŠ¨æ‘„åƒå¤´...');
        
                    // åœæ­¢å½“å‰æµ
                    if (currentStream) {
                        currentStream.getTracks().forEach(track => track.stop());
                        currentStream = null;
                    }

                    // é‡æ–°è·å–è®¾å¤‡åˆ—è¡¨
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    cameraDevices = devices.filter(device => device.kind === 'videoinput');
                    console.log(`âœ… å‘ç° ${cameraDevices.length} ä¸ªæ‘„åƒå¤´è®¾å¤‡`);
                    document.getElementById('switchCameraBtn').disabled = cameraDevices.length <= 1;

                    // æ„å»ºçº¦æŸæ¡ä»¶
                    const constraints = {
                        video: {
                            width: { ideal: 1280 },
                            height: { ideal: 720 },
                        },
                        audio: false
                    };

                    // åˆ¤æ–­å½“å‰ä½¿ç”¨çš„æ˜¯å‰ç½®è¿˜æ˜¯åç½®æ‘„åƒå¤´
                    let isFrontCamera = true; // é»˜è®¤å‰ç½®
                    
                    if (cameraDevices.length > 1) {
                        isFrontCamera = currentCameraIndex === 0;
                        constraints.video.facingMode = isFrontCamera ? 'user' : 'environment';
                    }

                    console.log('å°è¯•è·å–æ‘„åƒå¤´æµï¼Œçº¦æŸæ¡ä»¶:', constraints);
                    console.log('å½“å‰ä½¿ç”¨æ‘„åƒå¤´:', isFrontCamera ? 'å‰ç½®' : 'åç½®');

                    currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                    videoElement.srcObject = currentStream;

                    // æ ¹æ®æ‘„åƒå¤´ç±»å‹è®¾ç½®é•œåƒæ•ˆæœ
                    if (isFrontCamera) {
                        // å‰ç½®æ‘„åƒå¤´ï¼šåº”ç”¨åå‘é•œåƒæ¥æ˜¾ç¤ºçœŸå®ç”»é¢
                        videoElement.style.transform = 'scaleX(-1)';
                        videoElement.style.webkitTransform = 'scaleX(-1)';
                    } else {
                        // åç½®æ‘„åƒå¤´ï¼šé€šå¸¸ä¸éœ€è¦é•œåƒ
                        videoElement.style.transform = 'scaleX(1)';
                        videoElement.style.webkitTransform = 'scaleX(1)';
                    }

                    await new Promise((resolve, reject) => {
                        videoElement.onloadedmetadata = () => {
                            videoElement.play().then(resolve).catch(reject);
                            resetZoom();
                        };
                        videoElement.onerror = reject;
                        setTimeout(() => reject(new Error('è§†é¢‘åŠ è½½è¶…æ—¶')), 10000);
                    });

                    console.log('âœ… æ‘„åƒå¤´å¯åŠ¨æˆåŠŸï¼Œé•œåƒä¿®å¤å®Œæˆ');
                    console.log('é•œåƒçŠ¶æ€:', isFrontCamera ? 'å‰ç½®æ‘„åƒå¤´å·²ä¿®å¤é•œåƒ' : 'åç½®æ‘„åƒå¤´æ­£å¸¸æ˜¾ç¤º');

                    // åˆå§‹åŒ–ç¼©æ”¾æ§ä»¶
                    initZoomControls();

                } catch (error) {
                    console.error('å¯åŠ¨æ‘„åƒå¤´å¤±è´¥:', error);
                    let errorMsg = 'å¯åŠ¨æ‘„åƒå¤´å¤±è´¥: ';
                    switch (error.name) {
                        case 'NotAllowedError':
                            errorMsg += 'æƒé™è¢«æ‹’ç»ï¼Œè¯·å…è®¸è®¿é—®æ‘„åƒå¤´';
                            break;
                        case 'NotFoundError':
                            errorMsg += 'æœªæ‰¾åˆ°æ‘„åƒå¤´è®¾å¤‡';
                            break;
                        case 'NotReadableError':
                            errorMsg += 'æ‘„åƒå¤´è¢«å…¶ä»–åº”ç”¨å ç”¨æˆ–ç¡¬ä»¶é”™è¯¯';
                            break;
                        case 'OverconstrainedError':
                            errorMsg += 'æ‘„åƒå¤´å‚æ•°é…ç½®æœ‰è¯¯ï¼Œè¯·å°è¯•æ›´ä½çš„åˆ†è¾¨ç‡';
                            break;
                        case 'SecurityError':
                            errorMsg += 'å®‰å…¨é™åˆ¶ï¼Œè¯·ä½¿ç”¨HTTPS';
                            break;
                        default:
                            errorMsg += error.message || 'æœªçŸ¥é”™è¯¯';
                    }
                    showError(errorMsg);
                }
            }

            // åˆ‡æ¢æ‘„åƒå¤´
            document.getElementById('switchCameraBtn').addEventListener('click', async () => {
                if (cameraDevices.length > 1) {
                    currentCameraIndex = (currentCameraIndex + 1) % cameraDevices.length;
                    console.log(`åˆ‡æ¢åˆ°æ‘„åƒå¤´ ${currentCameraIndex + 1}/${cameraDevices.length}`);

                    // é‡ç½®ç¼©æ”¾
                    resetZoom();

                    await startCamera();
                } else {
                    showError('åªæœ‰ä¸€ä¸ªæ‘„åƒå¤´è®¾å¤‡å¯ç”¨');
                }
            });

            // è¿”å›AIè¯­éŸ³ç•Œé¢
            document.getElementById('backToVoiceBtn').addEventListener('click', () => {
                stopCallConversation(); 
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                }
                if (window.StatusBar) {
                    StatusBar.backgroundColorByHexString('#ffffff');
                    StatusBar.overlaysWebView(false);
                    StatusBar.show();
                }
                window.location.href = 'phone_call.html';
            });

            // ç»“æŸé€šè¯è¿”å›ä¸»ç•Œé¢
            document.getElementById('endCallBtn').addEventListener('click', () => {
                stopCallConversation(); 
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                }
                if (window.StatusBar) {
                    StatusBar.backgroundColorByHexString('#ffffff');
                    StatusBar.overlaysWebView(false);
                    StatusBar.show();
                }
                window.location.href = 'index.html';
            });

            // é¡µé¢å¸è½½æ—¶æ¸…ç†
            window.addEventListener('beforeunload', () => {
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                }
            });

            // å¯åŠ¨æ‘„åƒå¤´
            startCamera();
        }

        // å±å¹•æ–¹å‘æ§åˆ¶
        function lockOrientation(orientation) {
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock(orientation).then(() => {
                    console.log(`å±å¹•æ–¹å‘å·²é”å®šä¸º ${orientation}`);
                }).catch(err => {
                    console.error('é”å®šå±å¹•æ–¹å‘å¤±è´¥:', err);
                });
            } else {
                console.warn('è®¾å¤‡ä¸æ”¯æŒå±å¹•æ–¹å‘é”å®š');
            }
        }

        // åœ¨é¡µé¢åŠ è½½åç«‹å³è°ƒç”¨ï¼Œå°†å±å¹•é”å®šä¸ºæ¨ªå±
        window.addEventListener('load', () => {
            lockOrientation('landscape');
        });

        // å½“æ‚¨ä»è§†é¢‘é€šè¯ç•Œé¢è¿”å›æ—¶ï¼Œéœ€è¦è§£é”å±å¹•æ–¹å‘
        window.addEventListener('beforeunload', () => {
            if (screen.orientation && screen.orientation.unlock) {
                screen.orientation.unlock();
                console.log('å±å¹•æ–¹å‘å·²è§£é”');
            }
        });
        
        // è½¬æ¢ä¸º16ä½PCM
        function floatTo16BitPCM(float32Array) {
            const buffer = new ArrayBuffer(float32Array.length * 2);
            const view = new DataView(buffer);
            let offset = 0;
            for (let i = 0; i < float32Array.length; i++, offset += 2) {
                let s = Math.max(-1, Math.min(1, float32Array[i]));
                view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }
            return new Int16Array(buffer);
        }

        // åˆ›å»ºWAVæ–‡ä»¶
        function createWAVFile(audioData, sampleRate) {
            const length = audioData.length;
            const buffer = new ArrayBuffer(44 + length * 2);
            const view = new DataView(buffer);
            
            // WAVæ–‡ä»¶å¤´
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + length * 2, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, length * 2, true);
            
            // å†™å…¥éŸ³é¢‘æ•°æ®
            let offset = 44;
            for (let i = 0; i < audioData.length; i++) {
                view.setInt16(offset, audioData[i], true);
                offset += 2;
            }
            
            return buffer;
        }

         // è°ƒç”¨ASR API
        async function performASR(audioFilePath) {
            try {
                console.log('Starting ASR with filePath:', audioFilePath);
                const audioFile = await readAudioFile(audioFilePath);
                
                if (!(audioFile instanceof Blob)) {
                throw new Error('Invalid audio file: not a Blob or File object');
                }

                const formData = new FormData();
                formData.append('audio', audioFile, 'recording.wav');
                console.log('FormData prepared, audioFile size:', audioFile.size, 'type:', audioFile.type);

                // è°ƒç”¨ASR API
                const response = await fetch(`${SERVER_URL}/asr`, {
                method: 'POST',
                body: formData
                });

                if (!response.ok) {
                throw new Error(`ASR API request failed: ${response.status}`);
                }

                const result = await response.json();

                if (!result.success) {
                throw new Error(result.error || 'ASR processing failed');
                }

                // æ ¹æ®APIè¿”å›æ ¼å¼è·å–è¯†åˆ«ç»“æœ
                return result.transcription || '';

            } catch (error) {
                console.error('ASRè°ƒç”¨å¤±è´¥:', error);
                return '';
            }
        }

        // è¯»å–éŸ³é¢‘æ–‡ä»¶ï¼ˆç”¨äºå‘é€åˆ°ASR APIï¼‰
        function readAudioFile(filePath) {
            return new Promise((resolve, reject) => {
                console.log('Resolving file system URL:', filePath);
                window.resolveLocalFileSystemURL(filePath, (fileEntry) => {
                console.log('File entry resolved:', fileEntry.name);
                fileEntry.file(
                    (file) => {
                    console.log('File loaded (raw):', {
                        name: file.name,
                        size: file.size,
                        type: file.type,
                        isFile: file instanceof File,
                        isBlob: file instanceof Blob
                    });

                    // ä½¿ç”¨ FileReader è¯»å–æ–‡ä»¶å†…å®¹å¹¶åˆ›å»º Blob
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        const arrayBuffer = reader.result;
                        const blob = new Blob([arrayBuffer], { type: file.type || 'audio/wav' });
                        console.log('Converted to Blob:', {
                        size: blob.size,
                        type: blob.type,
                        isBlob: blob instanceof Blob
                        });
                        resolve(blob);
                    };
                    reader.onerror = (error) => {
                        console.error('FileReader error:', error);
                        reject(new Error('Failed to read file content: ' + error.message));
                    };
                    reader.readAsArrayBuffer(file);
                    },
                    (error) => {
                    console.error('Failed to read file:', error);
                    reject(new Error('Failed to read audio file: ' + error.message));
                    }
                );
                }, (error) => {
                console.error('Invalid file path:', filePath, error);
                reject(new Error('Invalid file path: ' + error.message));
                });
            });
        }
        
        function simulateLive2DClick()   {
            const live2dContainer = document.getElementById('live2d-container');
            const canvas = live2dContainer ? live2dContainer.querySelector('canvas') : document.querySelector('canvas');
            
            if (!canvas) {
                console.warn('æœªæ‰¾åˆ°Live2Dç”»å¸ƒå…ƒç´ ');
                return false;
            }
            
            const rect = canvas.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // æ›´å®Œæ•´çš„äº‹ä»¶åºåˆ—
            const events = [
                // è§¦æ‘¸å¼€å§‹
                new TouchEvent('touchstart', {
                bubbles: true,
                cancelable: true,
                touches: [new Touch({
                    identifier: 0,
                    target: canvas,
                    clientX: centerX,
                    clientY: centerY,
                    pageX: centerX + window.pageXOffset,
                    pageY: centerY + window.pageYOffset,
                    screenX: centerX,
                    screenY: centerY,
                    radiusX: 1,
                    radiusY: 1,
                    rotationAngle: 0,
                    force: 1
                })]
                }),
                
                // é¼ æ ‡æŒ‰ä¸‹
                new MouseEvent('mousedown', {
                bubbles: true,
                cancelable: true,
                clientX: centerX,
                clientY: centerY,
                button: 0,
                buttons: 1
                }),
                
                // è§¦æ‘¸ç»“æŸ
                new TouchEvent('touchend', {
                bubbles: true,
                cancelable: true,
                changedTouches: [new Touch({
                    identifier: 0,
                    target: canvas,
                    clientX: centerX,
                    clientY: centerY,
                    pageX: centerX + window.pageXOffset,
                    pageY: centerY + window.pageYOffset,
                    screenX: centerX,
                    screenY: centerY
                })]
                }),
                
                // é¼ æ ‡æŠ¬èµ·
                new MouseEvent('mouseup', {
                bubbles: true,
                cancelable: true,
                clientX: centerX,
                clientY: centerY,
                button: 0
                }),
                
                // ç‚¹å‡»äº‹ä»¶
                new MouseEvent('click', {
                bubbles: true,
                cancelable: true,
                clientX: centerX,
                clientY: centerY,
                button: 0
                }),
                
                // æŒ‡é’ˆäº‹ä»¶
                new PointerEvent('pointerdown', {
                bubbles: true,
                cancelable: true,
                clientX: centerX,
                clientY: centerY,
                pointerId: 1,
                pointerType: 'touch'
                }),
                
                new PointerEvent('pointerup', {
                bubbles: true,
                cancelable: true,
                clientX: centerX,
                clientY: centerY,
                pointerId: 1,
                pointerType: 'touch'
                })
            ];
            
            // ä¾æ¬¡è§¦å‘æ‰€æœ‰äº‹ä»¶
            events.forEach((event, index) => {
                setTimeout(() => {
                canvas.dispatchEvent(event);
                }, index * 10); // æ¯ä¸ªäº‹ä»¶é—´éš”10ms
            });
            
            console.log(`æ¨¡æ‹Ÿå®Œæ•´ç‚¹å‡»åºåˆ—: (${centerX}, ${centerY})`);
            return true;
        }
        // ========== é€šè¯çŠ¶æ€ç®¡ç† ==========
        class CallManager {
            constructor() {
                this.isCallActive = false;
                this.isProcessing = false;
                this.mediaRecorder = null;
                this.audioStream = null;
                this.audioContext = null;
                this.vadCheckInterval = null;
                this.silenceTimer = null;
                this.audioChunks = [];
                this.conversationHistory = [];
                this.analyser = null;
                this.hasDetectedSpeech = false; // æ–°å¢ï¼šæ ‡è®°æ˜¯å¦æ£€æµ‹åˆ°è¿‡è¯­éŸ³
                
                // é…ç½®å‚æ•°
                this.SILENCE_THRESHOLD = -20; // é™éŸ³é˜ˆå€¼ï¼ˆåˆ†è´ï¼‰
                this.SILENCE_DURATION = 50; // é™éŸ³æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
                this.SPEECH_THRESHOLD = -15; // è¯­éŸ³æ£€æµ‹é˜ˆå€¼ï¼ˆåˆ†è´ï¼‰

                this.capturedImages = []; // å­˜å‚¨æˆªå›¾çš„å…¨å±€å˜é‡åˆ—è¡¨
                this.maxImages = 1; // æœ€å¤šå­˜å‚¨5å¼ å›¾ç‰‡
                this.captureInterval = null; // æ–°å¢ï¼šæˆªå›¾å®šæ—¶å™¨
                this.captureFrequency = 100; // æ–°å¢ï¼šæˆªå›¾é¢‘ç‡ï¼Œæ¯500msæˆªä¸€å¼ 
            }

            // é‡ç½®æ‰€æœ‰çŠ¶æ€
            reset() {
                this.isCallActive = false;
                this.isProcessing = false;
                this.hasDetectedSpeech = false;
                this.audioChunks = [];
                this.conversationHistory = [];
                
                // æ¸…ç†å®šæ—¶å™¨
                if (this.vadCheckInterval) {
                clearInterval(this.vadCheckInterval);
                this.vadCheckInterval = null;
                }
                if (this.silenceTimer) {
                clearTimeout(this.silenceTimer);
                this.silenceTimer = null;
                }
                
                // åœæ­¢å½•éŸ³
                if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                this.mediaRecorder.stop();
                }
                this.mediaRecorder = null;
                
                // å…³é—­éŸ³é¢‘æµ
                if (this.audioStream) {
                this.audioStream.getTracks().forEach(track => track.stop());
                this.audioStream = null;
                }
                
                // å…³é—­éŸ³é¢‘ä¸Šä¸‹æ–‡
                if (this.audioContext && this.audioContext.state !== 'closed') {
                this.audioContext.close();
                this.audioContext = null;
                }
                
                this.analyser = null;

                this.capturedImages = []; // æ¸…ç©ºå›¾ç‰‡åˆ—è¡¨
        
                // æ¸…é™¤æˆªå›¾å®šæ—¶å™¨
                if (this.captureInterval) {
                    clearInterval(this.captureInterval);
                    this.captureInterval = null;
                }
            }

            // æˆªå›¾æ–¹æ³•ï¼ˆä¿æŒä¸å˜ï¼‰
            captureCurrentFrame() {
                try {
                    const videoElement = document.getElementById('cameraVideo');
                    if (!videoElement || videoElement.videoWidth === 0) {
                        console.warn('æ‘„åƒå¤´è§†é¢‘æµæ— æ•ˆï¼Œæ— æ³•æˆªå›¾');
                        return null;
                    }

                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = videoElement.videoWidth;
                    canvas.height = videoElement.videoHeight;
                    
                    ctx.drawImage(videoElement, 0, 0);
                    
                    const base64Image = canvas.toDataURL('image/jpeg', 0.8);
                    
                    this.capturedImages.push(base64Image);
                    if (this.capturedImages.length > this.maxImages) {
                        this.capturedImages.shift();
                    }
                    
                    console.log(`æˆªå›¾æˆåŠŸï¼Œå½“å‰å­˜å‚¨ ${this.capturedImages.length} å¼ å›¾ç‰‡`);
                    return base64Image;
                    
                } catch (error) {
                    console.error('æˆªå›¾å¤±è´¥:', error);
                    return null;
                }
            }

            // æ–°å¢ï¼šå¼€å§‹è¿ç»­æˆªå›¾
            startCapturing() {
                if (this.captureInterval) {
                    return; // å·²ç»åœ¨æˆªå›¾ä¸­
                }
                
                console.log('å¼€å§‹è¿ç»­æˆªå›¾');
                this.captureInterval = setInterval(() => {
                    if (this.isCallActive) {
                        this.captureCurrentFrame();
                    } else {
                        this.stopCapturing();
                    }
                }, this.captureFrequency);
            }

            // æ–°å¢ï¼šåœæ­¢è¿ç»­æˆªå›¾
            stopCapturing() {
                if (this.captureInterval) {
                    console.log('åœæ­¢è¿ç»­æˆªå›¾');
                    clearInterval(this.captureInterval);
                    this.captureInterval = null;
                }
            }

            // æ£€æŸ¥é€šè¯æ˜¯å¦å¤„äºæ´»åŠ¨çŠ¶æ€
            isActive() {
                return this.isCallActive;
            }

            // å¼€å§‹é€šè¯
            async start() {
                if (this.isCallActive) {
                console.warn('é€šè¯å·²ç»åœ¨è¿›è¡Œä¸­');
                return;
                }

                this.reset(); // ç¡®ä¿çŠ¶æ€å¹²å‡€
                this.isCallActive = true;
                
                const callStatus = document.getElementById('call-status');
                const callMessagesContainer = document.getElementById('call-messages-container');

                // æ¸…ç©ºä¹‹å‰çš„å¯¹è¯
                callMessagesContainer.innerHTML = '';

                try {
                // this.audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                this.audioStream = await navigator.mediaDevices.getUserMedia({ 
                audio: {
                    sampleRate: 16000,
                    channelCount: 1,
                    echoCancellation: true,
                    noiseSuppression: true
                }
                });
                await this.initializeAudioProcessing();
                this.startListening();
                } catch (error) {
                console.error('è·å–éº¦å…‹é£å¤±è´¥:', error);
                alert('æ— æ³•å¯ç”¨éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®ã€‚');
                this.reset();
                exitCallPage();
                }
            }

            // åœæ­¢é€šè¯
            stop() {
                console.log('åœæ­¢é€šè¯');
                this.reset();
                
                const callStatus = document.getElementById('call-status');
                callStatus.style.display = 'none';
            }

            // åˆå§‹åŒ–éŸ³é¢‘å¤„ç†
            async initializeAudioProcessing() {
                // this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                sampleRate: 16000
                });
                
                // è®¾ç½®éŸ³é¢‘åˆ†æ
                const source = this.audioContext.createMediaStreamSource(this.audioStream);
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 256;
                source.connect(this.analyser);
            }

            // å¼€å§‹ç›‘å¬
            startListening() {
                if (!this.isCallActive || this.isProcessing) {
                return;
                }

                console.log('å¼€å§‹ç›‘å¬...');
                const callStatus = document.getElementById('call-status');
                
                // é‡ç½®çŠ¶æ€
                this.audioChunks = [];
                this.hasDetectedSpeech = false;
                this.capturedImages = []; // æ¸…ç©ºä¹‹å‰çš„å›¾ç‰‡ï¼Œä¸ºæ–°ä¸€è½®å¯¹è¯åšå‡†å¤‡

                // è®¾ç½®å½•éŸ³å™¨é€‰é¡¹
                // è®¾ç½®MediaRecorder
                const options = {
                    mimeType: 'audio/webm;codecs=opus'
                };
                
                // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒçš„æ ¼å¼
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'audio/webm';
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options.mimeType = 'audio/mp4';
                        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                            delete options.mimeType;
                        }
                    }
                }

                this.mediaRecorder = new MediaRecorder(this.audioStream, options);

                this.mediaRecorder.ondataavailable = event => {
                    if (this.isCallActive && event.data && event.data.size > 0) {
                        console.log(`æ”¶åˆ°éŸ³é¢‘æ•°æ®å—: ${event.data.size} bytes`);
                        this.audioChunks.push(event.data);
                    }
                };

                this.mediaRecorder.onstart = () => {
                    if (!this.isCallActive) return;
                    console.log('å½•éŸ³å¼€å§‹...');
                    callStatus.textContent = 'ç­‰å¾…è¯­éŸ³è¾“å…¥...';
                    callStatus.style.display = 'block';
                };

                this.mediaRecorder.onstop = async () => {
                    if (!this.isCallActive) return;
                    console.log('å½•éŸ³ç»“æŸ');

                    // ç¡®ä¿åœæ­¢æˆªå›¾
                    this.stopCapturing();
                    
                    // åªæœ‰å½“æ£€æµ‹åˆ°è¯­éŸ³ä¸”æœ‰éŸ³é¢‘æ•°æ®æ—¶æ‰å¤„ç†
                    if (this.hasDetectedSpeech && this.audioChunks.length > 0) {
                        const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                        const audioFile = new File([audioBlob], "recording.wav", { type: "audio/wav" });
                        
                        if (audioFile.size > -1) { // ç¡®ä¿éŸ³é¢‘æ–‡ä»¶ä¸ä¸ºç©ºï¼ˆè‡³å°‘1KBï¼‰
                        console.log('æ£€æµ‹åˆ°æœ‰æ•ˆè¯­éŸ³ï¼Œå¼€å§‹å¤„ç†...');
                        await this.processAudio();
                        } else {
                        console.log('éŸ³é¢‘æ–‡ä»¶å¤ªå°ï¼Œè·³è¿‡å¤„ç†');
                        this.restartListening();
                        }
                    } else {
                        console.log('æœªæ£€æµ‹åˆ°è¯­éŸ³æˆ–æ— éŸ³é¢‘æ•°æ®ï¼Œé‡æ–°å¼€å§‹ç›‘å¬');
                        this.restartListening();
                    }
                };

                // å¯åŠ¨å½•éŸ³
                this.mediaRecorder.start();
                
                // å¯åŠ¨è¯­éŸ³æ´»åŠ¨æ£€æµ‹
                this.startVAD();
            }

            // å¯åŠ¨è¯­éŸ³æ´»åŠ¨æ£€æµ‹ï¼ˆVADï¼‰
            startVAD() {
                if (!this.analyser || !this.isCallActive) {
                return;
                }

                const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                const callStatus = document.getElementById('call-status');

                const checkAudio = () => {
                if (!this.isCallActive || !this.mediaRecorder || 
                    this.mediaRecorder.state !== 'recording' || this.isProcessing) {
                    return;
                }

                this.analyser.getByteFrequencyData(dataArray);
                let sum = dataArray.reduce((a, b) => a + b, 0);
                let average = sum / dataArray.length;
                let decibels = 20 * Math.log10(average / 255);

                // æ£€æµ‹åˆ°è¯­éŸ³ï¼ˆéŸ³é‡é«˜äºè¯­éŸ³é˜ˆå€¼ï¼‰
                if (decibels > this.SPEECH_THRESHOLD) {
                    if (!this.hasDetectedSpeech) {
                        console.log(`æ£€æµ‹åˆ°è¯­éŸ³å¼€å§‹: ${decibels.toFixed(2)} dB`);
                        this.hasDetectedSpeech = true;
                        callStatus.textContent = 'æ­£åœ¨è†å¬...';

                        // å¼€å§‹è¿ç»­æˆªå›¾
                        this.startCapturing();
                    }
                    
                    // æ¸…é™¤é™éŸ³è®¡æ—¶å™¨
                    if (this.silenceTimer) {
                        clearTimeout(this.silenceTimer);
                        this.silenceTimer = null;
                    }
                } 
                // æ£€æµ‹åˆ°é™éŸ³ï¼ˆéŸ³é‡ä½äºé™éŸ³é˜ˆå€¼ï¼‰ä¸”ä¹‹å‰æ£€æµ‹åˆ°è¿‡è¯­éŸ³
                else if (decibels < this.SILENCE_THRESHOLD && this.hasDetectedSpeech) {
                    if (!this.silenceTimer) {
                        console.log(`æ£€æµ‹åˆ°é™éŸ³å¼€å§‹: ${decibels.toFixed(2)} dB`);
                        this.silenceTimer = setTimeout(() => {
                            console.log('é™éŸ³æŒç»­è¶³å¤Ÿé•¿æ—¶é—´ï¼Œç»“æŸå½•éŸ³');
                            this.finishRecording();

                            // åœæ­¢è¿ç»­æˆªå›¾
                            this.stopCapturing();
                        }, this.SILENCE_DURATION);
                    }
                }
                };

                // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
                if (this.vadCheckInterval) {
                clearInterval(this.vadCheckInterval);
                }
                
                // æ¯100æ¯«ç§’æ£€æŸ¥ä¸€æ¬¡
                this.vadCheckInterval = setInterval(checkAudio, 100);
            }

            // ç»“æŸå½“å‰å½•éŸ³
            finishRecording() {
                if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                console.log('åœæ­¢å½•éŸ³...');
                this.mediaRecorder.stop();
                }
                
                // æ¸…ç†VAD
                if (this.vadCheckInterval) {
                clearInterval(this.vadCheckInterval);
                this.vadCheckInterval = null;
                }
                if (this.silenceTimer) {
                clearTimeout(this.silenceTimer);
                this.silenceTimer = null;
                }
            }

            // é‡æ–°å¼€å§‹ç›‘å¬
            restartListening() {
                if (!this.isCallActive) return;
                
                setTimeout(() => {
                if (this.isCallActive && !this.isProcessing) {
                    this.startListening();
                }
                }, 500);
            }

            // å¤„ç†éŸ³é¢‘
            async processAudio() {
                if (!this.isCallActive) return;
                
                this.isProcessing = true;
                const callStatus = document.getElementById('call-status');

                try {
                // 1. ä¿å­˜éŸ³é¢‘æ–‡ä»¶åˆ°æœ¬åœ°
                callStatus.textContent = 'æ­£åœ¨å¤„ç†å½•éŸ³...';

                // åˆ›å»ºéŸ³é¢‘blob
                const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                
                // è½¬æ¢ä¸ºArrayBuffer
                const arrayBuffer = await audioBlob.arrayBuffer();
                
                // è§£ç éŸ³é¢‘æ•°æ®
                const audioBufferObj = await this.audioContext.decodeAudioData(arrayBuffer);
                
                // ç¡®ä¿æ˜¯16kHzå•å£°é“
                const targetSampleRate = 16000;
                let audioData = audioBufferObj.getChannelData(0);
                
                // å¦‚æœé‡‡æ ·ç‡ä¸æ˜¯16kHzï¼Œè¿›è¡Œé‡é‡‡æ ·
                if (audioBufferObj.sampleRate !== targetSampleRate) {
                    audioData = downsampleBuffer(audioData, audioBufferObj.sampleRate, targetSampleRate);
                }
                
                // è½¬æ¢ä¸º16ä½PCM
                const int16Data = floatTo16BitPCM(audioData);
                
                // åˆ›å»ºWAVæ–‡ä»¶
                const wavBuffer = createWAVFile(int16Data, targetSampleRate);

                const audioFilePath = await this.saveAudioFile(wavBuffer);

                // 2. ASR (è¯­éŸ³è¯†åˆ«)
                callStatus.textContent = 'æ­£åœ¨è¯†åˆ«...';

                const asrResult =await performASR(audioFilePath)
                // const asrResult = "è¯·å›ç­”æˆ‘5ä¸ªå­—"
                
                if (!this.isCallActive) return; // æ£€æŸ¥çŠ¶æ€
                
                if (asrResult && asrResult.trim()) {
                    console.log('è¯†åˆ«ç»“æœ:', asrResult);
                    this.displayMessage(asrResult, 'user');

                    // 2. LLM (å¤§æ¨¡å‹)
                    callStatus.textContent = 'æ€è€ƒä¸­...';
                    const llmResponse = await this.getLlmResponse(asrResult);
                    // const llmResponse = "è¿™æ˜¯AIçš„æµ‹è¯•å›å¤å†…å®¹"; // ä¸´æ—¶æµ‹è¯•ç”¨
                    
                    if (!this.isCallActive) return; // æ£€æŸ¥çŠ¶æ€
                    
                    if (llmResponse && llmResponse.trim()) {
                        // 3. TTS (æ–‡æœ¬è½¬è¯­éŸ³)
                        const tts_success = await this.getTTSWav(llmResponse)
                        
                        if (!this.isCallActive) return; // æ£€æŸ¥çŠ¶æ€
                        
                        console.log('AI å›å¤:', llmResponse);
                        this.displayMessage(llmResponse, 'bot');

                        simulateLive2DClick();   
                    }
                } else {
                    console.log('æ²¡æœ‰è¯†åˆ«åˆ°æœ‰æ•ˆå†…å®¹');
                }
                
                } catch (error) {
                console.error('å¤„ç†éŸ³é¢‘æ—¶å‡ºé”™:', error);
                } finally {
                if (this.isCallActive) {
                    this.isProcessing = false;
                    callStatus.style.display = 'none';
                    this.restartListening();
                }
                }
            }

            // ä¿å­˜éŸ³é¢‘æ–‡ä»¶åˆ°Cordovaæ–‡ä»¶ç³»ç»Ÿ
            async saveAudioFile(wavBuffer) {
                return new Promise((resolve, reject) => {
                if (!window.cordova || !window.cordova.file) {
                    reject(new Error('Cordova file plugin not available'));
                    return;
                }

                window.resolveLocalFileSystemURL(cordova.file.dataDirectory, (dirEntry) => {
                    dirEntry.getDirectory('audio_temp', { create: true }, (chatWavDir) => {
                    const fileName = `recording.wav`;
                    // åˆ›å»ºæ–‡ä»¶
                    chatWavDir.getFile(fileName, { create: true }, (fileEntry) => {
                        // å†™å…¥æ–‡ä»¶
                        fileEntry.createWriter((fileWriter) => {
                        fileWriter.onwriteend = () => {
                            console.log('éŸ³é¢‘æ–‡ä»¶ä¿å­˜æˆåŠŸ:', fileEntry.nativeURL);
                            resolve(fileEntry.nativeURL);
                        };
                        
                        fileWriter.onerror = (e) => {
                            console.error('æ–‡ä»¶å†™å…¥å¤±è´¥:', e);
                            reject(e);
                        };
                        
                        // å°†ArrayBufferè½¬æ¢ä¸ºBlob
                        const blob = new Blob([wavBuffer], { type: 'audio/wav' });
                        fileWriter.write(blob);
                        });
                    }, reject);
                    }, reject);
                }, reject);
                });
            }

            // æ˜¾ç¤ºæ¶ˆæ¯
            displayMessage(text, role) {
                const container = document.getElementById('call-messages-container');
                const messageEl = document.createElement('div');
                messageEl.className = `call-message ${role}`;
                
                if(role === 'user') {
                    messageEl.textContent = 'æˆ‘ï¼š'+text;; // ç›´æ¥æ˜¾ç¤ºç”¨æˆ·å†…å®¹
                } else {
                    messageEl.textContent = '02ï¼š'+text; // ç›´æ¥æ˜¾ç¤ºAIå†…å®¹
                }
                
                container.appendChild(messageEl);

                // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
                container.scrollTop = container.scrollHeight;

                // 60ç§’åæ·¡å‡ºæ¶ˆå¤±
                setTimeout(() => {
                    messageEl.classList.add('fade-out');
                    setTimeout(() => {
                        if (container.contains(messageEl)) {
                            container.removeChild(messageEl);
                        }
                    }, 500);
                }, 60000);
            }

            async getLlmResponse(text) {
                if (!this.isCallActive) return null;
                
                this.conversationHistory.push({ role: 'user', content: text, files_path: this.capturedImages.slice() });
                try {
                    const response = await fetch(`${SERVER_URL}/chat`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ message: text, history: this.conversationHistory })
                    });
                    const data = await response.json();
                    if (data.success) {
                        this.conversationHistory.push({ role: 'assistant', content: data.response });
                        return data.response;
                    }
                    return null;
                } catch (error) {
                    console.error('LLM è¯·æ±‚å¤±è´¥:', error);
                    return null;
                }
            }

            async getTtsAudio(text) {
                if (!this.isCallActive) {
                console.log('é€šè¯å·²åœæ­¢ï¼Œå–æ¶ˆTTSè¯·æ±‚');
                return null;
                }

                try {
                const response = await fetch(`${SERVER_URL}/tts`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text })
                });
                return await response.blob();
                } catch (error) {
                console.error('TTS è¯·æ±‚å¤±è´¥:', error);
                return null;
                }
            }

            async getTTSWav(text) {
                // const serverUrl = "https://121.43.116.49:5000/tts"; // æ¢æˆä½ çš„æœåŠ¡å™¨åœ°å€
                const serverUrl = `${SERVER_URL}/tts`;

                try {
                    const response = await fetch(serverUrl, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({ text })
                    });

                    if (!response.ok) {
                        throw new Error("TTSè¯·æ±‚å¤±è´¥: " + response.status);
                    }

                    // è·å– ArrayBuffer
                    const arrayBuffer = await response.arrayBuffer();
                    const blob = new Blob([arrayBuffer], { type: "audio/wav" });

                    // ç­‰å¾…å†™å…¥å®Œæˆ
                    const filePath = await this.saveWavToFile(blob);
                    console.log("ä¸‹ä¸€æ­¥é€»è¾‘å¼€å§‹æ‰§è¡Œï¼Œæœ¬åœ°æ–‡ä»¶è·¯å¾„:", filePath);

                    return "audio.wav å·²ä¿å­˜";
                } catch (error) {
                    console.error("è°ƒç”¨TTSå¤±è´¥:", error);
                    return "TTSå¤±è´¥";
                }
            }

            async saveWavToFile(blob) {
                return new Promise((resolve, reject) => {
                    window.resolveLocalFileSystemURL(cordova.file.dataDirectory, function (dir) {
                        dir.getFile("audio.wav", { create: true }, function (file) {
                            file.createWriter(function (fileWriter) {
                                fileWriter.onwriteend = function () {
                                    console.log("âœ… audio.wav å·²ä¿å­˜åˆ°:", cordova.file.dataDirectory);
                                    resolve(cordova.file.dataDirectory + "audio.wav");
                                };
                                fileWriter.onerror = function (e) {
                                    console.error("ä¿å­˜å¤±è´¥:", e);
                                    reject(e);
                                };
                                fileWriter.write(blob);
                            }, reject);
                        }, reject);
                    }, reject);
                });
            }

            async playAudioFromBlob(audioBlob) {
                if (!this.isCallActive) return;
                
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio(audioUrl);
                
                return new Promise(resolve => {
                audio.onended = () => {
                    URL.revokeObjectURL(audioUrl);
                    resolve();
                };
                audio.onerror = () => {
                    console.error('éŸ³é¢‘æ’­æ”¾å¤±è´¥');
                    URL.revokeObjectURL(audioUrl);
                    resolve();
                };
                
                // æ£€æŸ¥é€šè¯çŠ¶æ€
                if (this.isCallActive) {
                    audio.play();
                } else {
                    URL.revokeObjectURL(audioUrl);
                    resolve();
                }
                });
            }
        }

        // ========== å…¨å±€å®ä¾‹ ==========
        const callManager = new CallManager();

        // ========== å¯¼å‡ºçš„å‡½æ•° ==========
        async function startCallConversation() {
            await callManager.start();
        }

        function stopCallConversation() {
            callManager.stop();
        }
    </script>
</body>
</html>