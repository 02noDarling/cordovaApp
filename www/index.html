<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>TypeScript HTML App</title>
  <style>
    * {
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
    }
    html, body {
      overflow: hidden;
      margin: 0;
      font-family: Arial, sans-serif;
      padding-top: constant(safe-area-inset-top);
      padding-top: env(safe-area-inset-top);
    }
    html {
      overscroll-behavior-x: none;
      touch-action: none;
      background-color: white !important;
    }
    body {
      display: flex;
      flex-direction: column;
      height: calc(100vh - env(safe-area-inset-top));
      height: calc(100vh - constant(safe-area-inset-top));
      background: transparent;
      margin-top: 0 !important;
      padding-top: 0 !important;
      top: 0 !important;
    }
    
    /* Live2D å®¹å™¨ */
    #live2d-container {
      position: relative;
      flex: 1;
      width: 100%;
      height: 425px; /* ä¸ºLive2Dé¢„ç•™ç©ºé—´ */
    }
    
    body > canvas:only-child {
      width: 100%;
      height: 100%;
    }
    
    /* æ‹–æ‹½å›¾æ ‡ */
    #drag-handle {
      position: absolute;
      right: -5px;
      top: 50%;
      transform: translateY(-50%);
      width: 40px;
      height: 100px;
      background: rgba(100, 100, 100, 0.6);
      border-radius: 10px 0 0 10px;
      cursor: move;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: background 0.2s, opacity 0.2s;
      opacity: 0;
    }

    /* æ”¶æ‹¢æŒ‰é’® */
    #collapse-button {
      position: absolute;
      left: -5px;
      top: 50%;
      transform: translateY(-50%);
      width: 40px;
      height: 80px;
      background: rgba(76, 175, 80, 0.6);
      border-radius: 0 10px 10px 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: background 0.2s, opacity 0.2s;
      opacity: 0;
      color: white;
      font-size: 16px;
    }

    #collapse-button:hover {
      background: rgba(76, 175, 80, 0.8);
    }

    /* é¼ æ ‡è¿›å…¥çª—å£åŒºåŸŸæ—¶æ˜¾ç¤ºæŒ‰é’® */
    #hover-detector:hover ~ #drag-handle,
    #drag-handle:hover,
    #hover-detector:hover ~ #collapse-button,
    #collapse-button:hover {
      opacity: 1;
    }

    /* å·¦ä¸Šè§’å…³é—­æŒ‰é’® */
    #close-button {
      position: absolute;
      top: 0;
      left: 0;
      width: 50px;
      height: 50px;
      cursor: pointer;
      z-index: 1000;
      background: rgba(255, 0, 0, 0.6);
      color: white;
      font-size: 20px;
      text-align: center;
      line-height: 50px;
      border-radius: 50%;
      opacity: 0;
      transition: opacity 0.2s ease-in-out;
    }

    /* é¼ æ ‡è¿›å…¥çª—å£åŒºåŸŸæ—¶æ˜¾ç¤ºå…³é—­æŒ‰é’® */
    #hover-detector:hover ~ #close-button,
    #close-button:hover {
      opacity: 1;
    }

    /* å·¦ä¸‹è§’ç¼©æ”¾æŒ‰é’® */
    #resize-handle {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 50px;
      height: 50px;
      cursor: nwse-resize;
      z-index: 1000;
      background: rgba(100, 100, 100, 0.6);
      color: white;
      font-size: 20px;
      text-align: center;
      line-height: 50px;
      border-radius: 0 50% 0 0;
      opacity: 0;
      transition: opacity 0.2s ease-in-out, background 0.2s;
    }

    #resize-handle:hover {
      background: rgba(100, 100, 100, 0.8);
    }

    /* é¼ æ ‡è¿›å…¥çª—å£åŒºåŸŸæ—¶æ˜¾ç¤ºç¼©æ”¾æŒ‰é’® */
    #hover-detector:hover ~ #resize-handle,
    #resize-handle:hover {
      opacity: 1;
    }
    
    /* åº•éƒ¨èŠå¤©åŒºåŸŸ */
    #bottom-container {
      width: 100%;
      height: 325px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 15px 15px 0 0;
      box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
      display: flex;
      box-sizing: border-box;
    }
    
    /* ä¼šè¯åˆ—è¡¨ */
    #sessions-panel {
      width: 200px;
      background: rgba(240, 240, 240, 0.9);
      border-radius: 15px 0 0 0;
      display: flex;
      flex-direction: column;
      padding: 10px;
      box-sizing: border-box;
      border-right: 1px solid rgba(200, 200, 200, 0.5);
    }
    
    /* æ–°å»ºä¼šè¯æŒ‰é’® */
    #new-chat-button {
      padding: 8px 12px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
      margin-bottom: 10px;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
    }
    
    #new-chat-button:hover {
      background: #45a049;
    }
    
    /* ä¼šè¯åˆ—è¡¨å®¹å™¨ */
    #sessions-list {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    /* ä¼šè¯é¡¹ */
    .session-item {
      position: relative;
      padding: 8px 10px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      transition: background 0.2s;
      word-wrap: break-word;
      line-height: 1.3;
      border: 2px solid transparent;
    }
    
    .session-item:hover {
      background: rgba(255, 255, 255, 1);
    }
    
    .session-item.active {
      background: rgba(76, 175, 80, 0.2);
      border-color: #4CAF50;
    }
    
    /* ä¼šè¯èœå•æŒ‰é’® */
    .session-menu-btn {
      position: absolute;
      right: 5px;
      top: 50%;
      transform: translateY(-50%);
      width: 20px;
      height: 20px;
      background: rgba(100, 100, 100, 0.6);
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 12px;
      display: none;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }
    
    .session-item:hover .session-menu-btn {
      display: flex;
    }
    
    .session-menu-btn:hover {
      background: rgba(100, 100, 100, 0.8);
    }
    
    /* ä¸‹æ‹‰èœå• */
    .dropdown-menu {
      position: absolute;
      top: 100%;
      right: 0;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      z-index: 1001;
      min-width: 80px;
      display: none;
    }
    
    .dropdown-menu.show {
      display: block;
    }
    
    .dropdown-item {
      padding: 8px 12px;
      cursor: pointer;
      font-size: 12px;
      color: #333;
      transition: background 0.2s;
    }
    
    .dropdown-item:hover {
      background: #f5f5f5;
    }
    
    .dropdown-item.delete {
      color: #e53e3e;
    }
    
    .dropdown-item.delete:hover {
      background: #fff5f5;
    }
    
    /* èŠå¤©æ¡†å®¹å™¨ */
    #chat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 15px;
      box-sizing: border-box;
    }
    
    /* èŠå¤©æ¶ˆæ¯æ˜¾ç¤ºåŒºåŸŸ */
    #chat-messages {
      flex: 1;
      background: rgba(245, 245, 245, 0.8);
      border-radius: 10px;
      padding: 10px;
      margin-bottom: 10px;
      overflow-y: auto;
      min-height: 80px;
      font-size: 14px;
      color: #333;
    }
    
    /* è¾“å…¥åŒºåŸŸ */
    #chat-input-container {
      display: flex;
      gap: 6px; /* å‡å°‘é—´è· */
      align-items: flex-end;
      padding-right: 8px; /* æ·»åŠ å³è¾¹è·ç¡®ä¿æŒ‰é’®å¯è§ */
    }
    
    /* æ–°å¢ï¼šè¾“å…¥æ¡†åŒ…è£…å™¨ */
    #input-wrapper {
      position: relative;
      flex: 1;
      display: flex;
      align-items: center;
      min-width: 0; /* ç¡®ä¿flexæ”¶ç¼© */
    }

    /* ä¿®æ”¹è¾“å…¥æ¡†ä¸ºtextareaå¹¶æ·»åŠ æ ·å¼ */
    #chat-input {
      flex: 1;
      padding: 8px 12px 35px 12px; /* åº•éƒ¨ç•™å‡ºç©ºé—´ç»™ä¸Šä¼ æŒ‰é’® */
      border: 2px solid #ddd;
      border-radius: 20px;
      outline: none;
      font-size: 14px;
      transition: border-color 0.2s;
      resize: none;
      overflow-y: auto;
      min-height: 40px;
      max-height: 120px; /* å‡å°‘æœ€å¤§é«˜åº¦ */
      line-height: 1.4;
      font-family: Arial, sans-serif;
      box-sizing: border-box;
      width: 100%; /* ç¡®ä¿å…¨å®½ */
    }
    
    #chat-input:focus {
      border-color: #4CAF50;
    }
    
    /* æ–‡ä»¶ä¸Šä¼ æŒ‰é’®åµŒå…¥æ ·å¼ */
    #file-upload-button {
      position: absolute;
      left: 8px;
      bottom: 4px;
      width: 24px;
      height: 24px;
      background: rgba(245, 245, 245, 0.9);
      border: 1px solid rgba(200, 200, 200, 0.8);
      border-radius: 50%;
      color: #666;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      z-index: 10;
      font-size: 14px;
      backdrop-filter: blur(2px); /* æ·»åŠ æ¨¡ç³ŠèƒŒæ™¯æ•ˆæœ */
    }

    #file-upload-button:hover {
      background: rgba(225, 225, 225, 0.95);
      color: #2196F3;
      border-color: #2196F3;
      transform: scale(1.1);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    #file-upload-button:active {
      transform: scale(0.95);
    }

    /* å½“è¾“å…¥æ¡†èšç„¦æ—¶ï¼Œä¸Šä¼ æŒ‰é’®æ ·å¼å˜åŒ– */
    #chat-input:focus ~ #file-upload-button {
      background: rgba(76, 175, 80, 0.1);
      border-color: #4CAF50;
      color: #4CAF50;
    }
    
    /* æ·»åŠ æç¤ºæ–‡æœ¬ */
    .input-hint {
      position: absolute;
      bottom: 50px;
      right: 115px; /* å¢åŠ è·ç¦»ï¼Œä¸ºæ–°æŒ‰é’®è®©å‡ºç©ºé—´ */
      font-size: 12px;
      color: #888;
      background: rgba(255, 255, 255, 0.8);
      padding: 2px 8px;
      border-radius: 10px;
      pointer-events: none;
    }
    
    #send-button {
      width: 36px;  /* ç»Ÿä¸€å‡å°æŒ‰é’®å°ºå¯¸ */
      height: 36px;
      background: #4CAF50;
      border: none;
      border-radius: 50%;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s, transform 0.1s;
      font-size: 14px; /* ç»Ÿä¸€å­—ä½“å¤§å° */
      flex-shrink: 0; /* é˜²æ­¢æŒ‰é’®è¢«å‹ç¼© */
    }
    
    #send-button:hover {
      background: #45a049;
    }
    
    #send-button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    #mic-button {
      width: 36px;  /* ç»Ÿä¸€å‡å°æŒ‰é’®å°ºå¯¸ */
      height: 36px;
      background: #4CAF50;
      border: none;
      border-radius: 50%;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s, transform 0.1s;
      font-size: 14px; /* ç»Ÿä¸€å­—ä½“å¤§å° */
      flex-shrink: 0; /* é˜²æ­¢æŒ‰é’®è¢«å‹ç¼© */
    }
    
    #mic-button:hover {
      background: #45a049;
    }
    
    #mic-button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    /* åŠ è½½åŠ¨ç”» */
    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #4CAF50;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .message {
      margin-bottom: 8px;
      padding: 8px;
      border-radius: 8px;
    }
    
    .user-message {
      background: #e3f2fd;
      text-align: right;
      margin-left: 20px;
    }
    
    .bot-message {
      background: #f1f8e9;
      margin-right: 20px;
    }
    
    /* æ»šåŠ¨æ¡æ ·å¼ */
    #sessions-list::-webkit-scrollbar,
    #chat-messages::-webkit-scrollbar {
      width: 6px;
    }
    
    #sessions-list::-webkit-scrollbar-track,
    #chat-messages::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.1);
      border-radius: 3px;
    }
    
    #sessions-list::-webkit-scrollbar-thumb,
    #chat-messages::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 3px;
    }
    
    #sessions-list::-webkit-scrollbar-thumb:hover,
    #chat-messages::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 0, 0, 0.5);
    }

    /* æ–°å¢éº¦å…‹é£æŒ‰é’®æ ·å¼ */
    #voice-toggle-button {
      width: 36px;  /* ç»Ÿä¸€å‡å°æŒ‰é’®å°ºå¯¸ */
      height: 36px;
      background: #4CAF50;
      border: none;
      border-radius: 50%;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s, transform 0.1s;
      font-size: 14px; /* ç»Ÿä¸€å­—ä½“å¤§å° */
      flex-shrink: 0; /* é˜²æ­¢æŒ‰é’®è¢«å‹ç¼© */
    }

    #voice-toggle-button:hover {
      background: #45a049;
    }

    #voice-toggle-button.disabled {
      background: #f44336;
    }

    #voice-toggle-button.disabled:hover {
      background: #d32f2f;
    }

    /* ä¸Šä¼ æ–‡ä»¶æ˜¾ç¤ºåŒºåŸŸ */
    #uploaded-files-container {
      background: rgba(245, 245, 245, 0.8);
      border-radius: 8px;
      padding: 8px;
      border: 1px solid rgba(200, 200, 200, 0.5);
    }

    #uploaded-files-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      max-height: 100px;
      overflow-y: auto;
    }

    /* æ–‡ä»¶é¡¹æ ·å¼ */
    .file-item {
      position: relative;
      background: white;
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 6px 20px 6px 8px; /* å³è¾¹ç•™ç©ºé—´ç»™åˆ é™¤æŒ‰é’® */
      font-size: 12px;
      max-width: 150px;
      display: flex;
      align-items: center;
      gap: 4px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .file-item .file-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
      color: #333;
    }

    .file-remove-btn {
      position: absolute;
      top: -4px;
      right: -4px;
      width: 16px;
      height: 16px;
      background: #f44336;
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      transition: all 0.2s;
    }

    .file-remove-btn:hover {
      background: #d32f2f;
      transform: scale(1.1);
    }

    /* æ–‡ä»¶åˆ—è¡¨æ»šåŠ¨æ¡æ ·å¼ */
    #uploaded-files-list::-webkit-scrollbar {
      width: 4px;
      height: 4px;
    }

    #uploaded-files-list::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.1);
      border-radius: 2px;
    }

    #uploaded-files-list::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 2px;
    }

     /* ç§»åŠ¨ç«¯é€‚é… */
     @media (max-width: 768px) {
      #sessions-panel {
        width: 120px; /* å‡å°ä¾§è¾¹æ å®½åº¦ */
        padding: 8px;
      }
      
      #chat-container {
        padding: 10px; /* å‡å°å†…è¾¹è· */
      }
      
      #chat-input-container {
        gap: 6px; /* è¿›ä¸€æ­¥å‡å°é—´è· */
        padding-right: 8px; /* å¢åŠ å³è¾¹è·ç¡®ä¿æŒ‰é’®å¯è§ */
      }
      
      #mic-button, #voice-toggle-button, #send-button {
        width: 32px; /* ç§»åŠ¨ç«¯æŒ‰é’®æ›´å° */
        height: 32px;
        font-size: 12px;
      }
      
      #chat-input {
        max-height: 100px; /* ç§»åŠ¨ç«¯è¾“å…¥æ¡†é«˜åº¦é™åˆ¶ */
        padding-right: 8px; /* ç¡®ä¿æ–‡å­—ä¸è¢«æŒ‰é’®é®ç›– */
      }
      
      .message {
        margin-left: 10px;
        margin-right: 10px;
        font-size: 13px;
      }
      
      .user-message {
        margin-left: 30px;
      }
      
      .bot-message {
        margin-right: 30px;
      }
    }

    /* è¶…å°å±å¹•é€‚é… */
    @media (max-width: 480px) {
      #bottom-container {
        height: 280px; /* å‡å°æ•´ä½“é«˜åº¦ */
      }
      
      #sessions-panel {
        width: 100px;
        padding: 5px;
      }
      
      #new-chat-button {
        font-size: 10px;
        padding: 6px 8px;
      }
      
      .session-item {
        font-size: 10px;
        padding: 6px 8px;
      }
      
      #chat-container {
        padding: 8px;
      }
      
      #chat-input-container {
        gap: 4px;
        padding-right: 10px;
      }
      
      #mic-button, #voice-toggle-button, #send-button {
        width: 28px;
        height: 28px;
        font-size: 11px;
      }
    }
  </style>
  <!-- Live2DCubismCore script -->
  <script src="./Core/live2dcubismcore.js"></script>
  <!-- Build script -->
  <script type="module" crossorigin src="/assets/index-BdKM-sSx.js"></script>
  <script src="cordova.js"></script>
</head>
<body>
  <!-- å…¨çª—å£é¼ æ ‡æ£€æµ‹å±‚ -->
  <div id="hover-detector" style="
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    opacity: 0;
    z-index: 999;
  "></div>

  <div id="live2d-container">
    <!-- Live2D canvas ä¼šè¢«æ’å…¥åˆ°è¿™é‡Œ -->
    <!-- <div id="drag-handle"></div>
    <div id="collapse-button">Â«</div> -->
  </div>
  
  <!-- <div id="close-button">Ã—</div> -->
  <!-- <div id="resize-handle">â†”â†•</div> -->

  <div id="bottom-container">
    <!-- ä¼šè¯åˆ—è¡¨é¢æ¿ -->
    <div id="sessions-panel">
      <button id="new-chat-button">
        <span>+</span>
        <span>æ–°å¯¹è¯</span>
      </button>
      <div id="sessions-list">
        <!-- ä¼šè¯åˆ—è¡¨é¡¹å°†åœ¨è¿™é‡ŒåŠ¨æ€æ·»åŠ  -->
      </div>
    </div>
    
    <!-- èŠå¤©åŒºåŸŸ -->
    <div id="chat-container">
      <div id="chat-messages">
        <div class="message bot-message">ä½ å¥½ï¼æˆ‘æ˜¯02ï¼Œæœ‰ä»€ä¹ˆæƒ³èŠçš„å—ï¼Ÿ</div>
      </div>
      <!-- æ·»åŠ è¿™ä¸ªæ–‡ä»¶æ˜¾ç¤ºåŒºåŸŸ -->
      <div id="uploaded-files-container" style="display: none; margin-bottom: 10px;">
        <div id="uploaded-files-list"></div>
      </div>
      <!-- åŸèŠå¤©è¾“å…¥åŒº -->
      <div id="chat-input-container">
        <div id="input-wrapper">
          <textarea id="chat-input" placeholder="è¾“å…¥æ¶ˆæ¯..." rows="1"></textarea>
          <button id="file-upload-button" title="ä¸Šä¼ æ–‡ä»¶">
            <span style="font-size: 16px;">+</span>
          </button>
          <input type="file" id="file-input" multiple accept=".txt,.png,.jpg,.jpeg,.gif,.pdf,.doc,.docx" style="display: none;">
        </div>
        <button id="mic-button" title="ç‚¹å‡»å¼€å§‹å½•éŸ³"><span>ğŸ™ï¸</span></button>
        <button id="voice-toggle-button" title="è¯­éŸ³æ’­æ”¾æ§åˆ¶"><span id="voice-icon">ğŸ”Š</span></button>
        <button id="send-button"><span>â†’</span></button>
      </div>

      <!-- å½•éŸ³ç•Œé¢ -->
      <div id="recording-container" style="display:none; flex-direction:column; align-items:center; justify-content:center; width:100%;">
        <canvas id="waveform" style="width:100%; height:60px;"></canvas>
        <button id="stop-recording" style="margin-top:10px; padding:5px 15px;">ç»“æŸå½•éŸ³</button>
      </div>
    </div>
  </div>

  <script>
    // const { ipcRenderer } = require('electron');
    
    // å…¨å±€å˜é‡
    let currentSessionId = null;
    let sessions = [];
    let isVoiceEnabled = true; // æ–°å¢ï¼šè¯­éŸ³æ§åˆ¶å˜é‡
    
    // ä¼šè¯ç®¡ç†åŠŸèƒ½
    const newChatButton = document.getElementById('new-chat-button');
    const sessionsList = document.getElementById('sessions-list');
    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const sendButton = document.getElementById('send-button');

    document.addEventListener('deviceready', () => {
      if (window.StatusBar) {
        StatusBar.overlaysWebView(false);
        StatusBar.backgroundColorByHexString('#ffffff'); // æ”¹æˆç™½è‰²æˆ–ä½ æƒ³è¦çš„é¢œè‰²
        StatusBar.styleDefault(); // æˆ–è€… StatusBar.styleLightContent()
      }
      
      // å¼ºåˆ¶éšè—ç³»ç»ŸUI
      if (window.AndroidFullScreen) {
        AndroidFullScreen.showSystemUI();
      }

      // æ–‡ä»¶ç³»ç»Ÿç›¸å…³ä»£ç 
      console.log(window.cordova.file.dataDirectory);

      initCanvas();

      // åˆå§‹åŒ–ä¼šè¯
      initSessions();
      
      // åˆå§‹åŒ–è¯­éŸ³æ§åˆ¶ï¼ˆæ–°å¢ï¼‰
      initVoiceControl();

      initFileUpload(); // æ·»åŠ è¿™è¡Œ
    });
    
    // æ–°å¢ï¼šè¯­éŸ³æ§åˆ¶åŠŸèƒ½
    function initVoiceControl() {
      const voiceToggleButton = document.getElementById('voice-toggle-button');
      const voiceIcon = document.getElementById('voice-icon');
      
      if (!voiceToggleButton || !voiceIcon) {
        console.error('Voice control elements not found');
        return;
      }
      
      // æ›´æ–°éº¦å…‹é£æŒ‰é’®çŠ¶æ€
      function updateVoiceButtonState() {
        if (isVoiceEnabled) {
          voiceToggleButton.classList.remove('disabled');
          voiceToggleButton.title = 'è¯­éŸ³æ’­æ”¾å·²å¯ç”¨ï¼Œç‚¹å‡»ç¦ç”¨';
          voiceIcon.textContent = 'ğŸ”Š';
        } else {
          voiceToggleButton.classList.add('disabled');
          voiceToggleButton.title = 'è¯­éŸ³æ’­æ”¾å·²ç¦ç”¨ï¼Œç‚¹å‡»å¯ç”¨';
          voiceIcon.textContent = 'ğŸš«';
        }
      }

      // åŒæ­¥å¤–éƒ¨JSæ–‡ä»¶ä¸­çš„å…¨å±€å˜é‡
      function syncExternalGlobalVariable() {
        try {
          // æ–¹æ³•1: ç›´æ¥è®¿é—®å…¨å±€å˜é‡ï¼ˆå¦‚æœåœ¨åŒä¸€ä¸ªwindowä½œç”¨åŸŸï¼‰
          if (typeof window._isAudioEnabled !== 'undefined') {
            window._isAudioEnabled = isVoiceEnabled;
            console.log('Updated _isAudioEnabled via window:', window._isAudioEnabled);
          }
          
        } catch (error) {
          console.warn('Failed to sync external global variable:', error);
        }
      }
      
      // éº¦å…‹é£æŒ‰é’®ç‚¹å‡»äº‹ä»¶
      voiceToggleButton.addEventListener('click', () => {
        isVoiceEnabled = !isVoiceEnabled;
        updateVoiceButtonState();
        syncExternalGlobalVariable();
      });
      
      // åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€
      updateVoiceButtonState();
      syncExternalGlobalVariable();
    }
    
    // åˆå§‹åŒ–ä¼šè¯åˆ—è¡¨
    async function initSessions() {
      try {
        sessions = await getAllSessions();
        if (sessions.length === 0) {
          // å¦‚æœæ²¡æœ‰ä¼šè¯ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„
          await createNewSession();
        } else {
          // é€‰æ‹©æœ€æ–°çš„ä¼šè¯
          currentSessionId = sessions[0].id;
          await loadSessionHistory(currentSessionId);
        }
        renderSessionsList();
      } catch (error) {
        console.error('Failed to initialize sessions:', error);
        await createNewSession();
      }
    }

    function getAllSessions() {
      return new Promise((resolve, reject) => {
        window.resolveLocalFileSystemURL(cordova.file.dataDirectory + 'chat_history/', (dirEntry) => {
          let directoryReader = dirEntry.createReader();
          directoryReader.readEntries((entries) => {
            const sessionPromises = entries
              .filter(entry => entry.isFile && entry.name.endsWith('.jsonl'))
              .map(entry => {
                return new Promise((resolveSession) => {
                  entry.file((file) => {
                    const reader = new FileReader();
                    reader.onloadend = function () {
                      const sessionId = entry.name.replace('.jsonl', '');
                      let sessionName = sessionId;
                      try {
                        const content = this.result;
                        const lines = content.trim().split('\n').filter(line => line.trim());
                        if (lines.length > 0) {
                          const firstMessage = JSON.parse(lines[0]);
                          if (firstMessage.role === 'user') {
                            sessionName = firstMessage.content.substring(0, 20) + (firstMessage.content.length > 20 ? '...' : '');
                          }
                        }
                      } catch (error) {
                        console.error('Error reading session file:', error);
                      }
                      resolveSession({
                        id: sessionId,
                        name: sessionName,
                        createdAt: file.lastModifiedDate || new Date(),
                        modifiedAt: file.lastModifiedDate || new Date()
                      });
                    };
                    reader.onerror = () => resolveSession({ id: entry.name.replace('.jsonl', ''), name: entry.name, createdAt: new Date(), modifiedAt: new Date() });
                    reader.readAsText(file);
                  }, (error) => {
                    console.error('Error getting file:', error);
                    resolveSession({ id: entry.name.replace('.jsonl', ''), name: entry.name, createdAt: new Date(), modifiedAt: new Date() });
                  });
                });
              });

            Promise.all(sessionPromises)
              .then(sessions => {
                resolve(sessions.sort((a, b) => b.modifiedAt - a.modifiedAt));
              })
              .catch(reject);
          }, reject);
        }, (error) => {
          console.error('Error accessing chat_history directory:', error);
          // å¦‚æœç›®å½•ä¸å­˜åœ¨ï¼Œåˆ›å»ºå®ƒ
          window.resolveLocalFileSystemURL(cordova.file.dataDirectory, (dirEntry) => {
            dirEntry.getDirectory('chat_history', { create: true }, () => {
              console.log('chat_history directory created');
              resolve([]); // ç›®å½•åˆ›å»ºåè¿”å›ç©ºä¼šè¯åˆ—è¡¨
            }, reject);
          }, reject);
        });
      });
    }

    // ç”Ÿæˆæ–°çš„ä¼šè¯ID
    function generateSessionId() {
      return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    async function createNewSession() {
      const sessionId = generateSessionId();
      console.log('Session ID:', sessionId);

      // è®¿é—® dataDirectory
      window.resolveLocalFileSystemURL(cordova.file.dataDirectory, function (dirEntry) {
        console.log("dataDirectory è·¯å¾„:", dirEntry.fullPath); // æ‰“å°ç›®å½•è·¯å¾„
        console.log("dataDirectory è·¯å¾„ (toURL):", dirEntry.toURL());

        // åˆ›å»ºæˆ–è®¿é—® chat_history å­ç›®å½•
        dirEntry.getDirectory('chat_history', { create: true, exclusive: false }, function (chatDirEntry) {
          console.log("chat_history ç›®å½•è·¯å¾„:", chatDirEntry.fullPath); // æ‰“å° chat_history è·¯å¾„

          // åœ¨ chat_history ç›®å½•ä¸­åˆ›å»ºæ–‡ä»¶
          chatDirEntry.getFile(sessionId + ".jsonl", { create: true, exclusive: false }, function (fileEntry) {
            console.log("æ–°å»ºä¼šè¯æ–‡ä»¶:", fileEntry.fullPath); // åº”ä¸º /chat_history/sessionId.jsonl

            // æ›´æ–°å†…å­˜é‡Œçš„ session åˆ—è¡¨
            const newSession = {
              id: sessionId,
              name: `æ–°å¯¹è¯ ${new Date().toLocaleString()}`,
              createdAt: new Date(),
              modifiedAt: new Date()
            };
            sessions.unshift(newSession);
            currentSessionId = newSession.id;
            clearChatMessages();
            addMessage("ä½ å¥½ï¼æˆ‘æ˜¯02ï¼Œæœ‰ä»€ä¹ˆæƒ³èŠçš„å—ï¼Ÿ", false);
            renderSessionsList();
          }, function (error) {
            console.error("åˆ›å»ºæ–‡ä»¶å¤±è´¥:", error);
          });
        }, function (error) {
          console.error("åˆ›å»º chat_history ç›®å½•å¤±è´¥:", error);
        });
      }, function (error) {
        console.error("è®¿é—® dataDirectory å¤±è´¥:", error);
      });
    }
    
    // æ¸²æŸ“ä¼šè¯åˆ—è¡¨
    function renderSessionsList() {
      sessionsList.innerHTML = '';
      sessions.forEach(session => {
        const sessionItem = document.createElement('div');
        sessionItem.className = `session-item ${session.id === currentSessionId ? 'active' : ''}`;
        sessionItem.innerHTML = `
          <div style="padding-right: 25px;">${session.name}</div>
          <button class="session-menu-btn" data-session-id="${session.id}">â‹¯</button>
          <div class="dropdown-menu">
            <div class="dropdown-item delete" data-action="delete" data-session-id="${session.id}">åˆ é™¤</div>
          </div>
        `;
        
        // ç‚¹å‡»ä¼šè¯åˆ‡æ¢
        sessionItem.addEventListener('click', (e) => {
          if (!e.target.classList.contains('session-menu-btn') && !e.target.classList.contains('dropdown-item')) {
            switchToSession(session.id);
          }
        });
        
        sessionsList.appendChild(sessionItem);
      });
      
      // æ·»åŠ ä¼šè¯èœå•äº‹ä»¶ç›‘å¬
      setupSessionMenus();
    }
    
    // è®¾ç½®ä¼šè¯èœå•äº‹ä»¶
    function setupSessionMenus() {
      const menuButtons = document.querySelectorAll('.session-menu-btn');
      const dropdownMenus = document.querySelectorAll('.dropdown-menu');
      
      menuButtons.forEach(button => {
        button.addEventListener('click', (e) => {
          e.stopPropagation();
          const dropdown = button.nextElementSibling;
          
          // å…³é—­å…¶ä»–ä¸‹æ‹‰èœå•
          dropdownMenus.forEach(menu => {
            if (menu !== dropdown) {
              menu.classList.remove('show');
            }
          });
          
          // åˆ‡æ¢å½“å‰ä¸‹æ‹‰èœå•
          dropdown.classList.toggle('show');
        });
      });
      
      // ç‚¹å‡»ä¸‹æ‹‰èœå•é¡¹
      const dropdownItems = document.querySelectorAll('.dropdown-item');
      dropdownItems.forEach(item => {
        item.addEventListener('click', async (e) => {
          e.stopPropagation();
          const action = item.dataset.action;
          const sessionId = item.dataset.sessionId;
          
          if (action === 'delete') {
            await deleteSession(sessionId);
          }
          
          // å…³é—­ä¸‹æ‹‰èœå•
          item.closest('.dropdown-menu').classList.remove('show');
        });
      });
      
      // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­ä¸‹æ‹‰èœå•
      document.addEventListener('click', () => {
        dropdownMenus.forEach(menu => {
          menu.classList.remove('show');
        });
      });
    }
    
    // åˆ‡æ¢åˆ°æŒ‡å®šä¼šè¯
    async function switchToSession(sessionId) {
      if (currentSessionId === sessionId) return;
      
      currentSessionId = sessionId;
      await loadSessionHistory(sessionId);
      renderSessionsList();
    }
    
    // åŠ è½½ä¼šè¯å†å²
    async function loadSessionHistory(sessionId) {
      try {
        // const history = await ipcRenderer.invoke('get-session-history', sessionId);
        const history = await getSessionHistory(sessionId); // è·å–ä¼šè¯å†å²
        console.log(history)
        clearChatMessages();
        
        if (history.length === 0) {
          addMessage('ä½ å¥½ï¼æˆ‘æ˜¯02ï¼Œæœ‰ä»€ä¹ˆæƒ³èŠçš„å—ï¼Ÿ', false);
        } else {
          // history.forEach(message => {
          //   addMessage(message.content, message.role === 'user', message.wav_path || '', message.files_path);
          // });
          history.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
          for (const message of history) {
            await addMessage(message.content, message.role === 'user', message.wav_path || '', message.files_path);
          }
        }
      } catch (error) {
        console.error('Failed to load session history:', error);
        clearChatMessages();
        addMessage('ä½ å¥½ï¼æˆ‘æ˜¯02ï¼Œæœ‰ä»€ä¹ˆæƒ³èŠçš„å—ï¼Ÿ', false);
      }
    }

    function getSessionHistory(sessionId) {
      return new Promise((resolve, reject) => {
        const filePath = cordova.file.dataDirectory + 'chat_history/' + sessionId + '.jsonl';
        window.resolveLocalFileSystemURL(filePath, (fileEntry) => {
          fileEntry.file((file) => {
            const reader = new FileReader();
            reader.onloadend = function () {
              try {
                const content = this.result;
                const lines = content.trim().split('\n').filter(line => line.trim());
                const history = lines.map(line => JSON.parse(line));
                resolve(history);
              } catch (error) {
                console.error('Error parsing session history:', error);
                resolve([]); // è§£æå¤±è´¥è¿”å›ç©ºæ•°ç»„
              }
            };
            reader.onerror = () => {
              console.error('Error reading file:', reader.error);
              resolve([]); // è¯»å–å¤±è´¥è¿”å›ç©ºæ•°ç»„
            };
            reader.readAsText(file);
          }, (error) => {
            console.error('Error getting file:', error);
            resolve([]); // æ–‡ä»¶ä¸å­˜åœ¨æˆ–æ— æ³•è®¿é—®è¿”å›ç©ºæ•°ç»„
          });
        }, (error) => {
          console.error('Error accessing file path:', error);
          resolve([]); // è·¯å¾„æ— æ•ˆæˆ–æ–‡ä»¶ä¸å­˜åœ¨è¿”å›ç©ºæ•°ç»„
        });
      });
    }
    
    // åˆ é™¤ä¼šè¯
    async function deleteSession(sessionId) {
      if (sessions.length <= 1) {
        await showCustomAlertDialog('è‡³å°‘éœ€è¦ä¿ç•™ä¸€ä¸ªä¼šè¯');
        return;
      }
      
      const shouldDelete = await showCustomConfirmDialog('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªä¼šè¯å—ï¼Ÿ');
      if (!shouldDelete) return;
      
      try {
        // const success = await ipcRenderer.invoke('delete-session', sessionId);
        const success = await deleteSessionFiles(sessionId); // åˆ é™¤æ–‡ä»¶å’Œç›®å½•
        if (success) {
          sessions = sessions.filter(s => s.id !== sessionId);
          
          if (currentSessionId === sessionId) {
            if (sessions.length > 0) {
              currentSessionId = sessions[0].id;
              await loadSessionHistory(currentSessionId);
            } else {
              await createNewSession();
            }
          }
          
          renderSessionsList();
        }
        
        // ç¡®ä¿æ“ä½œå®Œæˆåé‡æ–°èšç„¦è¾“å…¥æ¡†
        setTimeout(() => {
          chatInput.focus();
        }, 100);
      } catch (error) {
        console.error('Failed to delete session:', error);
        await showCustomAlertDialog('åˆ é™¤ä¼šè¯å¤±è´¥');
        chatInput.focus();
      }
    }

    // åˆ é™¤ä¼šè¯ç›¸å…³æ–‡ä»¶å’Œç›®å½•
    function deleteSessionFiles(sessionId) {
      return new Promise((resolve, reject) => {
        // å®šä¹‰æ–‡ä»¶å’Œç›®å½•è·¯å¾„
        const historyPath = cordova.file.dataDirectory + 'chat_history/' + sessionId + '.jsonl';
        const wavPath = cordova.file.dataDirectory + 'chat_wav/' + sessionId; // å‡è®¾ wav ç›®å½•
        const filesPath = cordova.file.dataDirectory + 'chat_files/' + sessionId; // å‡è®¾ files ç›®å½•

        // è®¡æ•°å™¨ï¼Œç¡®ä¿æ‰€æœ‰åˆ é™¤æ“ä½œå®Œæˆ
        let pendingDeletions = 3; // history, wav, files
        let hasError = false;

        function checkComplete() {
          pendingDeletions--;
          if (pendingDeletions === 0) {
            resolve(!hasError);
          }
        }

        // åˆ é™¤å†å²æ–‡ä»¶
        window.resolveLocalFileSystemURL(historyPath, (fileEntry) => {
          fileEntry.remove(() => {
            console.log('History file deleted:', historyPath);
            checkComplete();
          }, (error) => {
            console.warn('History file not found or failed to delete:', error);
            checkComplete();
          });
        }, (error) => {
          console.warn('History file path invalid:', error);
          checkComplete();
        });

        // åˆ é™¤ wav ç›®å½•
        window.resolveLocalFileSystemURL(wavPath, (dirEntry) => {
          dirEntry.removeRecursively(() => {
            console.log('Wav directory deleted:', wavPath);
            checkComplete();
          }, (error) => {
            console.warn('Wav directory not found or failed to delete:', error);
            checkComplete();
          });
        }, (error) => {
          console.warn('Wav directory path invalid:', error);
          checkComplete();
        });

        // åˆ é™¤ files ç›®å½•
        window.resolveLocalFileSystemURL(filesPath, (dirEntry) => {
          dirEntry.removeRecursively(() => {
            console.log('Files directory deleted:', filesPath);
            checkComplete();
          }, (error) => {
            console.warn('Files directory not found or failed to delete:', error);
            checkComplete();
          });
        }, (error) => {
          console.warn('Files directory path invalid:', error);
          checkComplete();
        });
      });
    }

    // è‡ªå®šä¹‰ç¡®è®¤å¯¹è¯æ¡†å‡½æ•°
    function showCustomConfirmDialog(message) {
      return new Promise((resolve) => {
        // åˆ›å»ºé®ç½©å±‚
        const overlay = document.createElement('div');
        overlay.style.position = 'fixed';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.right = '0';
        overlay.style.bottom = '0';
        overlay.style.backgroundColor = 'rgba(0,0,0,0.5)';
        overlay.style.zIndex = '9998';
        overlay.style.display = 'flex';
        overlay.style.alignItems = 'center';
        overlay.style.justifyContent = 'center';
        
        // åˆ›å»ºå¯¹è¯æ¡†
        const dialog = document.createElement('div');
        dialog.style.backgroundColor = 'white';
        dialog.style.padding = '20px';
        dialog.style.borderRadius = '10px';
        dialog.style.boxShadow = '0 4px 20px rgba(0,0,0,0.2)';
        dialog.style.zIndex = '9999';
        dialog.style.width = '300px';
        dialog.style.maxWidth = '80%';
        
        dialog.innerHTML = `
          <div style="margin-bottom: 15px; font-size: 16px;">${message}</div>
          <div style="display: flex; justify-content: flex-end; gap: 10px;">
            <button id="confirm-cancel" style="padding: 8px 15px; background: #f0f0f0; border: none; border-radius: 5px; cursor: pointer;">å–æ¶ˆ</button>
            <button id="confirm-ok" style="padding: 8px 15px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">ç¡®å®š</button>
          </div>
        `;
        
        // æ·»åŠ åˆ°é®ç½©å±‚
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
        
        // å¤„ç†æŒ‰é’®ç‚¹å‡»
        const handleOk = () => {
          cleanup();
          resolve(true);
        };
        
        const handleCancel = () => {
          cleanup();
          resolve(false);
        };
        
        document.getElementById('confirm-ok').addEventListener('click', handleOk);
        document.getElementById('confirm-cancel').addEventListener('click', handleCancel);
        
        // æ¸…ç†å‡½æ•°
        const cleanup = () => {
          document.getElementById('confirm-ok').removeEventListener('click', handleOk);
          document.getElementById('confirm-cancel').removeEventListener('click', handleCancel);
          document.body.removeChild(overlay);
        };
        
        // ç‚¹å‡»é®ç½©å±‚ä¹Ÿå–æ¶ˆ
        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) {
            handleCancel();
          }
        });
        
        // é˜»æ­¢å¯¹è¯æ¡†å†…éƒ¨ç‚¹å‡»äº‹ä»¶å†’æ³¡
        dialog.addEventListener('click', (e) => {
          e.stopPropagation();
        });
      });
    }

    // è‡ªå®šä¹‰è­¦å‘Šå¯¹è¯æ¡†å‡½æ•°
    function showCustomAlertDialog(message) {
      return new Promise((resolve) => {
        // åˆ›å»ºé®ç½©å±‚
        const overlay = document.createElement('div');
        overlay.style.position = 'fixed';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.right = '0';
        overlay.style.bottom = '0';
        overlay.style.backgroundColor = 'rgba(0,0,0,0.5)';
        overlay.style.zIndex = '9998';
        overlay.style.display = 'flex';
        overlay.style.alignItems = 'center';
        overlay.style.justifyContent = 'center';
        
        // åˆ›å»ºå¯¹è¯æ¡†
        const dialog = document.createElement('div');
        dialog.style.backgroundColor = 'white';
        dialog.style.padding = '20px';
        dialog.style.borderRadius = '10px';
        dialog.style.boxShadow = '0 4px 20px rgba(0,0,0,0.2)';
        dialog.style.zIndex = '9999';
        dialog.style.width = '300px';
        dialog.style.maxWidth = '80%';
        
        dialog.innerHTML = `
          <div style="margin-bottom: 15px; font-size: 16px;">${message}</div>
          <div style="display: flex; justify-content: flex-end;">
            <button id="alert-ok" style="padding: 8px 15px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">ç¡®å®š</button>
          </div>
        `;
        
        // æ·»åŠ åˆ°é®ç½©å±‚
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
        
        // å¤„ç†æŒ‰é’®ç‚¹å‡»
        const handleOk = () => {
          cleanup();
          resolve();
        };
        
        const cleanup = () => {
          document.getElementById('alert-ok').removeEventListener('click', handleOk);
          document.body.removeChild(overlay);
        };
        
        document.getElementById('alert-ok').addEventListener('click', handleOk);
        
        // ç‚¹å‡»é®ç½©å±‚ä¹Ÿå…³é—­
        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) {
            handleOk();
          }
        });
        
        // é˜»æ­¢å¯¹è¯æ¡†å†…éƒ¨ç‚¹å‡»äº‹ä»¶å†’æ³¡
        dialog.addEventListener('click', (e) => {
          e.stopPropagation();
        });
      });
    }
    
    // æ¸…ç©ºèŠå¤©æ¶ˆæ¯
    function clearChatMessages() {
      chatMessages.innerHTML = '';
    }

    // æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©ç•Œé¢
    async function addMessage(content, isUser = false, wav_path = '', files_path=[]) {
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${isUser ? 'user-message' : 'bot-message'}`;

      // ===== ç”¨æˆ·è¯­éŸ³æ¶ˆæ¯ =====
      if (isUser && wav_path) {
        let audio;
        try {
          // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
          console.log('Checking wav_path:', wav_path);
          const fileExists = await new Promise((resolve) => {
            window.resolveLocalFileSystemURL(wav_path, () => resolve(true), () => resolve(false));
          });
          if (!fileExists) {
            throw new Error('Audio file does not exist at: ' + wav_path);
          }

          const audioBlob = await new Promise((resolve, reject) => {
            window.resolveLocalFileSystemURL(wav_path, (fileEntry) => {
              fileEntry.file((file) => {
                console.log('Audio file loaded:', {
                  name: file.name,
                  size: file.size,
                  type: file.type,
                  isFile: file instanceof File,
                  isBlob: file instanceof Blob,
                  constructorName: file.constructor.name,
                  toString: Object.prototype.toString.call(file)
                });
                // å¦‚æœ file ä¸æ˜¯ Blob æˆ– Fileï¼Œå°è¯•æ‰‹åŠ¨åˆ›å»º Blob
                if (!(file instanceof Blob)) {
                  console.warn('File object is not a Blob, attempting to convert');
                  // å‡è®¾ file åŒ…å«åŸå§‹æ•°æ®ï¼Œå°è¯•ä» file è¯»å–æ•°æ®
                  const reader = new FileReader();
                  reader.onload = () => {
                    const arrayBuffer = reader.result;
                    const blob = new Blob([arrayBuffer], { type: 'audio/x-wav' });
                    resolve(blob);
                  };
                  reader.onerror = (error) => reject(error);
                  reader.readAsArrayBuffer(file);
                } else {
                  resolve(file);
                }
              }, (error) => {
                console.error('Failed to load audio file:', error);
                reject(error);
              });
            }, (error) => {
              console.error('Invalid wav_path:', wav_path, error);
              reject(error);
            });
          });

          // å†æ¬¡æ£€æŸ¥ audioBlob ç±»å‹
          console.log('audioBlob type:', {
            isBlob: audioBlob instanceof Blob,
            isFile: audioBlob instanceof File,
            constructorName: audioBlob.constructor.name,
            toString: Object.prototype.toString.call(audioBlob)
          });
          if (!(audioBlob instanceof Blob)) {
            throw new Error('audioBlob is not a Blob or File object: ' + Object.prototype.toString.call(audioBlob));
          }

          const audioUrl = URL.createObjectURL(audioBlob);
          audio = new Audio(audioUrl);
          console.log('Audio URL created:', audioUrl);

          // Revoke Blob URL when audio is no longer needed
          audio.addEventListener('ended', () => URL.revokeObjectURL(audioUrl));
          audio.addEventListener('error', () => URL.revokeObjectURL(audioUrl));
        } catch (error) {
          console.error('Error creating Audio element:', error);
          const errorDiv = document.createElement('div');
          errorDiv.textContent = 'æ— æ³•åŠ è½½éŸ³é¢‘æ–‡ä»¶: ' + error.message;
          errorDiv.style.color = 'red';
          messageDiv.appendChild(errorDiv);
          chatMessages.appendChild(messageDiv);
          chatMessages.scrollTop = chatMessages.scrollHeight;
          return;
        }

        const voiceWrapper = document.createElement('div');
        voiceWrapper.style.display = 'inline-flex';
        voiceWrapper.style.alignItems = 'center';
        voiceWrapper.style.background = '#e0f7fa';
        voiceWrapper.style.padding = '6px 12px';
        voiceWrapper.style.borderRadius = '8px';
        voiceWrapper.style.cursor = 'pointer';
        voiceWrapper.style.userSelect = 'none';
        voiceWrapper.style.marginBottom = '4px';

        // å›¾æ ‡
        const icon = document.createElement('span');
        icon.textContent = 'ğŸ”Š';
        icon.style.marginRight = '8px';
        icon.style.fontSize = '16px';

        // æ—¶é•¿
        const durationSpan = document.createElement('span');
        durationSpan.style.fontSize = '14px';
        durationSpan.style.color = '#333';

        audio.addEventListener('loadedmetadata', () => {
          durationSpan.textContent = `${Math.round(audio.duration)}"`;
        });

        // ç‚¹å‡»æ’­æ”¾
        let isPlaying = false;
        voiceWrapper.addEventListener('click', () => {
          if (!isPlaying) {
            audio.play();
          } else {
            audio.pause();
            audio.currentTime = 0;
          }
        });
        audio.addEventListener('play', () => {
          isPlaying = true;
          icon.textContent = 'ğŸ”ˆ';
        });
        audio.addEventListener('ended', () => {
          isPlaying = false;
          icon.textContent = 'ğŸ”Š';
        });
        audio.addEventListener('pause', () => {
          isPlaying = false;
          icon.textContent = 'ğŸ”Š';
        });

        voiceWrapper.appendChild(icon);
        voiceWrapper.appendChild(durationSpan);
        messageDiv.appendChild(voiceWrapper);

        // === æ–‡ä»¶åˆ—è¡¨ï¼ˆå¦‚æœæœ‰ä¸Šä¼ æ–‡ä»¶ï¼‰ ===
        if (isUser && files_path && files_path.length > 0) {
          const fileListDiv = document.createElement('div');
          fileListDiv.style.display = 'flex';
          fileListDiv.style.flexWrap = 'wrap';
          fileListDiv.style.marginTop = '4px';
          fileListDiv.style.marginBottom = '4px';
          fileListDiv.style.gap = '6px';
          fileListDiv.style.justifyContent = 'flex-end'; // âœ… å³å¯¹é½

          files_path.forEach(file_path => {
            const fileItem = document.createElement('div');
            const file_name = file_path.split("_").pop();
            fileItem.style.display = 'flex';
            fileItem.style.alignItems = 'center';
            fileItem.style.padding = '3px 6px';
            fileItem.style.border = '1px solid #ddd';
            fileItem.style.borderRadius = '4px';
            fileItem.style.background = '#fff';
            fileItem.style.fontSize = '12px';
            fileItem.style.cursor = 'pointer'; // âœ… å¯ç‚¹å‡»

            const iconSpan = document.createElement('span');
            iconSpan.textContent = getFileIcon(file_name);
            iconSpan.style.marginRight = '4px';

            const nameSpan = document.createElement('span');
            nameSpan.textContent = file_name;
            nameSpan.title = file_name;

            fileItem.appendChild(iconSpan);
            fileItem.appendChild(nameSpan);
            fileListDiv.appendChild(fileItem);

            // === ç‚¹å‡»äº‹ä»¶ ===
            fileItem.addEventListener('click', () => {
              const ext = file_name.split('.').pop().toLowerCase();
              if (['png','jpg','jpeg','gif','webp'].includes(ext)) {
                showImagePreview(file_path); // åº”ç”¨å†…é¢„è§ˆ
              } else {
                ipcRenderer.invoke('open-file', file_path); // ç³»ç»Ÿé»˜è®¤ç¨‹åº/è®°äº‹æœ¬
              }
            });
          });

          messageDiv.appendChild(fileListDiv);
        }

        // === è¯­éŸ³è½¬æ–‡å­—éƒ¨åˆ† ===
        const transcriptDiv = document.createElement('div');
        transcriptDiv.innerHTML = `
          <div style="
            font-weight: bold;
            color: #4CAF50;
            background: linear-gradient(90deg, #ff0000, #ff9900, #33cc33, #3399ff, #9900cc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 2px;
          ">è¯­éŸ³è½¬æ–‡å­—ï¼š</div>
          <div>${content.replace(/\n/g, '<br>')}</div>
        `;
        transcriptDiv.style.fontSize = '13px';
        transcriptDiv.style.marginTop = '4px';
        messageDiv.appendChild(transcriptDiv);

      } else {
        // ===== æ™®é€šæ–‡å­—æ¶ˆæ¯ =====
        // å¦‚æœæœ‰æ–‡ä»¶ï¼Œä¹ŸåŠ æ–‡ä»¶åˆ—è¡¨
        if (isUser && files_path && files_path.length > 0) {
          const fileListDiv = document.createElement('div');
          fileListDiv.style.display = 'flex';
          fileListDiv.style.flexWrap = 'wrap';
          fileListDiv.style.marginBottom = '4px';
          fileListDiv.style.gap = '6px';
          fileListDiv.style.justifyContent = 'flex-end'; // âœ… å³å¯¹é½

          files_path.forEach(file_path => {
            const fileItem = document.createElement('div');
            const file_name = file_path.split("_").pop();
            fileItem.style.display = 'flex';
            fileItem.style.alignItems = 'center';
            fileItem.style.padding = '3px 6px';
            fileItem.style.border = '1px solid #ddd';
            fileItem.style.borderRadius = '4px';
            fileItem.style.background = '#fff';
            fileItem.style.fontSize = '12px';
            fileItem.style.cursor = 'pointer'; // âœ… å¯ç‚¹å‡»

            const iconSpan = document.createElement('span');
            iconSpan.textContent = getFileIcon(file_name);
            iconSpan.style.marginRight = '4px';

            const nameSpan = document.createElement('span');
            nameSpan.textContent = file_name;
            nameSpan.title = file_name;

            fileItem.appendChild(iconSpan);
            fileItem.appendChild(nameSpan);
            fileListDiv.appendChild(fileItem);

            // === ç‚¹å‡»äº‹ä»¶ ===
            fileItem.addEventListener('click', () => {
              const ext = file_name.split('.').pop().toLowerCase();
              if (['png','jpg','jpeg','gif','webp'].includes(ext)) {
                showImagePreview(file_path); // åº”ç”¨å†…é¢„è§ˆ
              } else {
                ipcRenderer.invoke('open-file', file_path); // ç³»ç»Ÿé»˜è®¤ç¨‹åº/è®°äº‹æœ¬
              }
            });
          });

          messageDiv.appendChild(fileListDiv);
        }

        // æœ€ååŠ æ–‡å­—
        const textDiv = document.createElement('div');
        textDiv.innerHTML = content.replace(/\n/g, '<br>');
        messageDiv.appendChild(textDiv);
      }

      chatMessages.appendChild(messageDiv);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    function showLoading() {
      const loadingDiv = document.createElement('div');
      loadingDiv.className = 'message bot-message';
      loadingDiv.innerHTML = '<div class="loading"></div> æ€è€ƒä¸­...';
      loadingDiv.id = 'loading-message';
      chatMessages.appendChild(loadingDiv);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    function hideLoading() {
      const loadingMessage = document.getElementById('loading-message');
      if (loadingMessage) {
        loadingMessage.remove();
      }
    }
    
    // ä¿®æ”¹sendMessageå‡½æ•°ï¼Œæ·»åŠ è¯­éŸ³æ§åˆ¶å‚æ•°
    async function sendMessage() {
      const message = chatInput.value.trim();
      if (!message || !currentSessionId) return;
      
      let files_path = []
      for (const file of uploadedFiles) {
        files_path.push(file.path);
      }
      
      // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
      addMessage(message, true, '', files_path);
      chatInput.value = '';
      resetTextareaHeight(); // é‡ç½®è¾“å…¥æ¡†é«˜åº¦
      
      // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
      sendButton.disabled = true;
      sendButton.innerHTML = '<div class="loading" style="width: 16px; height: 16px; border-width: 1px;"></div>';
      showLoading();

      // æ¸…ç©ºfilesåˆ—è¡¨
      uploadedFiles = []
      updateUploadedFilesDisplay();
      
      try {
        // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°å†å²æ–‡ä»¶
        await addMessageToSession(currentSessionId, 'user', message, '', files_path);

        // è·å–ä¼šè¯å†å²
        const history = await getSessionHistory(currentSessionId);

        // è°ƒç”¨æœåŠ¡å™¨è·å–å›å¤
        const response = await getModelResponse(message, history, isVoiceEnabled);
        const tts_success = await getTTSWav(response)
        // saveTestWavToDataDirectory()
        simulateLive2DClick()

        hideLoading();
        addMessage(response, false);

        // æ·»åŠ åŠ©æ‰‹å›å¤åˆ°å†å²æ–‡ä»¶
        await addMessageToSession(currentSessionId, 'assistant', response);

        // æ›´æ–°ä¼šè¯åˆ—è¡¨
        sessions = await getAllSessions();
        renderSessionsList();
      } catch (error) {
        hideLoading();
        addMessage('æŠ±æ­‰ï¼Œå‡ºç°äº†ä¸€äº›é—®é¢˜ï¼Œè¯·ç¨åå†è¯•ã€‚');
        console.error('Chat error:', error);
      } finally {
        sendButton.disabled = false;
        sendButton.innerHTML = '<span>â†’</span>';
      }
    }

    // æ¨¡æ‹Ÿç‚¹å‡» Live2D ç”»å¸ƒä¸­å¿ƒç‚¹çš„å‡½æ•°ï¼ˆä½¿ç”¨ TouchEvent ä»¥å…¼å®¹ç§»åŠ¨è®¾å¤‡ï¼‰
    function simulateLive2DClick()   {
      const live2dContainer = document.getElementById('live2d-container');
      const canvas = live2dContainer ? live2dContainer.querySelector('canvas') : document.querySelector('canvas');
      
      if (!canvas) {
        console.warn('æœªæ‰¾åˆ°Live2Dç”»å¸ƒå…ƒç´ ');
        return false;
      }
      
      const rect = canvas.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      // æ›´å®Œæ•´çš„äº‹ä»¶åºåˆ—
      const events = [
        // è§¦æ‘¸å¼€å§‹
        new TouchEvent('touchstart', {
          bubbles: true,
          cancelable: true,
          touches: [new Touch({
            identifier: 0,
            target: canvas,
            clientX: centerX,
            clientY: centerY,
            pageX: centerX + window.pageXOffset,
            pageY: centerY + window.pageYOffset,
            screenX: centerX,
            screenY: centerY,
            radiusX: 1,
            radiusY: 1,
            rotationAngle: 0,
            force: 1
          })]
        }),
        
        // é¼ æ ‡æŒ‰ä¸‹
        new MouseEvent('mousedown', {
          bubbles: true,
          cancelable: true,
          clientX: centerX,
          clientY: centerY,
          button: 0,
          buttons: 1
        }),
        
        // è§¦æ‘¸ç»“æŸ
        new TouchEvent('touchend', {
          bubbles: true,
          cancelable: true,
          changedTouches: [new Touch({
            identifier: 0,
            target: canvas,
            clientX: centerX,
            clientY: centerY,
            pageX: centerX + window.pageXOffset,
            pageY: centerY + window.pageYOffset,
            screenX: centerX,
            screenY: centerY
          })]
        }),
        
        // é¼ æ ‡æŠ¬èµ·
        new MouseEvent('mouseup', {
          bubbles: true,
          cancelable: true,
          clientX: centerX,
          clientY: centerY,
          button: 0
        }),
        
        // ç‚¹å‡»äº‹ä»¶
        new MouseEvent('click', {
          bubbles: true,
          cancelable: true,
          clientX: centerX,
          clientY: centerY,
          button: 0
        }),
        
        // æŒ‡é’ˆäº‹ä»¶
        new PointerEvent('pointerdown', {
          bubbles: true,
          cancelable: true,
          clientX: centerX,
          clientY: centerY,
          pointerId: 1,
          pointerType: 'touch'
        }),
        
        new PointerEvent('pointerup', {
          bubbles: true,
          cancelable: true,
          clientX: centerX,
          clientY: centerY,
          pointerId: 1,
          pointerType: 'touch'
        })
      ];
      
      // ä¾æ¬¡è§¦å‘æ‰€æœ‰äº‹ä»¶
      events.forEach((event, index) => {
        setTimeout(() => {
          canvas.dispatchEvent(event);
        }, index * 10); // æ¯ä¸ªäº‹ä»¶é—´éš”10ms
      });
      
      console.log(`æ¨¡æ‹Ÿå®Œæ•´ç‚¹å‡»åºåˆ—: (${centerX}, ${centerY})`);
      return true;
    }
    
    function saveTestWavToDataDirectory() {
        return new Promise((resolve, reject) => {
            // å¯ç”¨çš„WAVæ–‡ä»¶åˆ—è¡¨
            const wavFiles = ['test_1.wav', 'test_2.wav', 'test_3.wav', 'test_4.wav'];
            
            // éšæœºé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶
            const randomIndex = Math.floor(Math.random() * wavFiles.length);
            const selectedFile = wavFiles[randomIndex];
            
            console.log('Randomly selected file:', selectedFile);
            
            // æºæ–‡ä»¶è·¯å¾„ï¼ˆç›¸å¯¹äº www ç›®å½•ï¼‰
            const sourcePath = 'file:///android_asset/www/' + selectedFile;
            // ç›®æ ‡è·¯å¾„ï¼ˆdataDirectory ä¸‹çš„ audio.wavï¼‰
            const targetPath = cordova.file.dataDirectory + 'audio.wav';

            console.log('Source path:', sourcePath);
            console.log('Target path:', targetPath);

            // ç¡®ä¿ dataDirectory å¯è®¿é—®
            window.resolveLocalFileSystemURL(cordova.file.dataDirectory, (dirEntry) => {
                // è®¿é—®æºæ–‡ä»¶
                window.resolveLocalFileSystemURL(sourcePath, (sourceFileEntry) => {
                    // å¤åˆ¶æ–‡ä»¶åˆ° dataDirectoryï¼Œä¿å­˜ä¸º audio.wav
                    sourceFileEntry.copyTo(dirEntry, 'audio.wav', (targetFileEntry) => {
                        console.log('Selected file (' + selectedFile + ') saved as audio.wav to:', targetFileEntry.fullPath);
                        resolve({
                            targetPath: targetFileEntry.fullPath,
                            selectedFile: selectedFile,
                            targetUrl: targetFileEntry.toURL()
                        });
                    }, (error) => {
                        console.error('Failed to copy ' + selectedFile + ' as audio.wav:', error);
                        reject(error);
                    });
                }, (error) => {
                    console.error('Source file (' + selectedFile + ') not found or inaccessible:', error);
                    reject(error);
                });
            }, (error) => {
                console.error('Data directory inaccessible:', error);
                reject(error);
            });
        });
    }

    async function getModelResponse(message, history, enableVoice) {
        // è·å–æœåŠ¡å™¨åœ°å€ - ä½ éœ€è¦æ›¿æ¢ä¸ºä½ çš„å®é™…IPåœ°å€
        const serverUrl = 'https://192.168.31.71:5000/chat';
        
        const requestBody = {
            message: message,
            history: history || [],
            enableVoice: enableVoice || false
        };

        console.log('å‘é€è¯·æ±‚åˆ°æœåŠ¡å™¨:', serverUrl);
        console.log('è¯·æ±‚æ•°æ®:', requestBody);

        try {
            const response = await fetch(serverUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                body: JSON.stringify(requestBody),
                // è®¾ç½®è¶…æ—¶æ—¶é—´
                timeout: 30000
            });

            console.log('æœåŠ¡å™¨å“åº”çŠ¶æ€:', response.status);

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Server error: ${response.status} - ${errorText}`);
            }

            const data = await response.json();
            console.log('æœåŠ¡å™¨å“åº”æ•°æ®:', data);

            if (data.success) {
                return data.response;
            } else {
                throw new Error(data.error || 'æœåŠ¡å™¨å¤„ç†å¤±è´¥');
            }

        } catch (error) {
            console.error('è°ƒç”¨æœåŠ¡å™¨å¤±è´¥:', error);
            
            // ç½‘ç»œé”™è¯¯çš„å…·ä½“å¤„ç†
            if (error.name === 'TypeError' && error.message.includes('fetch')) {
                console.error('ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨æ˜¯å¦è¿è¡Œ');
                return 'æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ã€‚';
            }
            
            return getFallbackResponse(message); // ä½¿ç”¨å¤‡ç”¨å›å¤
        }
    }

    function saveWavToFile(blob) {
        return new Promise((resolve, reject) => {
            window.resolveLocalFileSystemURL(cordova.file.dataDirectory, function (dir) {
                dir.getFile("audio.wav", { create: true }, function (file) {
                    file.createWriter(function (fileWriter) {
                        fileWriter.onwriteend = function () {
                            console.log("âœ… audio.wav å·²ä¿å­˜åˆ°:", cordova.file.dataDirectory);
                            resolve(cordova.file.dataDirectory + "audio.wav");
                        };
                        fileWriter.onerror = function (e) {
                            console.error("ä¿å­˜å¤±è´¥:", e);
                            reject(e);
                        };
                        fileWriter.write(blob);
                    }, reject);
                }, reject);
            }, reject);
        });
    }

    async function getTTSWav(text) {
        const serverUrl = "https://192.168.31.71:5000/tts"; // æ¢æˆä½ çš„æœåŠ¡å™¨åœ°å€

        try {
            const response = await fetch(serverUrl, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({ text })
            });

            if (!response.ok) {
                throw new Error("TTSè¯·æ±‚å¤±è´¥: " + response.status);
            }

            // è·å– ArrayBuffer
            const arrayBuffer = await response.arrayBuffer();
            const blob = new Blob([arrayBuffer], { type: "audio/wav" });

            // ç­‰å¾…å†™å…¥å®Œæˆ
            const filePath = await saveWavToFile(blob);
            console.log("ä¸‹ä¸€æ­¥é€»è¾‘å¼€å§‹æ‰§è¡Œï¼Œæœ¬åœ°æ–‡ä»¶è·¯å¾„:", filePath);

            return "audio.wav å·²ä¿å­˜";
        } catch (error) {
            console.error("è°ƒç”¨TTSå¤±è´¥:", error);
            return "TTSå¤±è´¥";
        }
    }

    // æ·»åŠ æ¶ˆæ¯åˆ°ä¼šè¯å†å²æ–‡ä»¶ (.jsonl)
    function addMessageToSession(sessionId, role, content, wav_path = '', files_path = []) {
      return new Promise((resolve, reject) => {
        const filePath = cordova.file.dataDirectory + 'chat_history/' + sessionId + '.jsonl';
        window.resolveLocalFileSystemURL(filePath, (fileEntry) => {
          fileEntry.createWriter((fileWriter) => {
            fileWriter.onwriteend = () => {
              console.log('Message added to session:', sessionId);
              resolve();
            };
            fileWriter.onerror = reject;

            // ç§»åŠ¨åˆ°æ–‡ä»¶æœ«å°¾
            fileWriter.seek(fileWriter.length);

            // å†™å…¥æ–°æ¶ˆæ¯ï¼ˆJSON å¯¹è±¡ + æ¢è¡Œï¼‰
            const messageObj = {
              role: role,
              content: content,
              wav_path: wav_path,
              files_path: files_path,
              timestamp: new Date().toISOString()
            };
            const data = JSON.stringify(messageObj) + '\n';
            fileWriter.write(data);
          }, reject);
        }, reject);
      });
    }

    // è°ƒæ•´textareaé«˜åº¦
    function adjustTextareaHeight() {
      // é‡ç½®é«˜åº¦ä»¥æ­£ç¡®è®¡ç®—scrollHeight
      chatInput.style.height = 'auto';
      // è®¾ç½®é«˜åº¦ä¸ºå†…å®¹é«˜åº¦ï¼ˆä½†ä¸è¶…è¿‡æœ€å¤§é«˜åº¦ï¼‰
      chatInput.style.height = Math.min(chatInput.scrollHeight, 150) + 'px';
    }
    
    // é‡ç½®textareaé«˜åº¦
    function resetTextareaHeight() {
      chatInput.style.height = 'auto';
    }
    
    // äº‹ä»¶ç›‘å¬
    newChatButton.addEventListener('click', createNewSession);
    sendButton.addEventListener('click', sendMessage);
    
    // // ä¿®æ”¹é”®ç›˜äº‹ä»¶å¤„ç† - æ”¯æŒShift+Enteræ¢è¡Œ
    // chatInput.addEventListener('keydown', function(e) {
    //   if (e.key === 'Enter' && !e.shiftKey) {
    //     // Enteré”®å•ç‹¬æŒ‰ä¸‹ - å‘é€æ¶ˆæ¯
    //     e.preventDefault(); // é˜»æ­¢é»˜è®¤æ¢è¡Œè¡Œä¸º
    //     sendMessage();
    //   } else if (e.key === 'Enter' && e.shiftKey) {
    //     // Shift+Enter - æ’å…¥æ¢è¡Œ
    //     // ä¸éœ€è¦é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œæµè§ˆå™¨ä¼šè‡ªåŠ¨æ’å…¥æ¢è¡Œ
    //     // ä½†æˆ‘ä»¬éœ€è¦åœ¨è¾“å…¥åè°ƒæ•´é«˜åº¦
    //     setTimeout(adjustTextareaHeight, 0);
    //   }
    // });
    // è¾“å…¥æ—¶è‡ªåŠ¨è°ƒæ•´é«˜åº¦
    chatInput.addEventListener('input', function() {
      adjustTextareaHeight();
    });
    
    // ç¡®ä¿ Live2D canvas è¢«æ­£ç¡®æ”¾ç½®åœ¨å®¹å™¨ä¸­
    document.addEventListener('DOMContentLoaded', () => {
      
      // è§‚å¯Ÿ canvas å…ƒç´ çš„æ·»åŠ 
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.addedNodes.forEach((node) => {
            if (node.tagName === 'CANVAS') {
              const container = document.getElementById('live2d-container');
              if (container && node.parentElement === document.body) {
                container.appendChild(node);
                node.style.width = '100%';
                node.style.height = '100%';
              }
            }
          });
        });
      });
      
      observer.observe(document.body, { childList: true });
    });
    
    // const { WaveFile } = require('wavefile');
    let isRecording = false;
    let mediaRecorder;
    let audioChunks = [];
    let audioContext;
    let analyser;
    let dataArray;
    let animationId;

    const micButton = document.getElementById('mic-button');
    const chatInputContainer = document.getElementById('chat-input-container');
    const recordingContainer = document.getElementById('recording-container');
    const stopRecordingBtn = document.getElementById('stop-recording');
    const waveformCanvas = document.getElementById('waveform');
    const ctx = waveformCanvas.getContext('2d');

    // åˆå§‹åŒ–canvaså°ºå¯¸
    function initCanvas() {
      const rect = waveformCanvas.getBoundingClientRect();
      console.log('Canvas dimensions:', rect.width, rect.height);
      waveformCanvas.width = rect.width || 100; // æä¾›é»˜è®¤å€¼
      waveformCanvas.height = rect.height || 60; // æä¾›é»˜è®¤å€¼
    }

    micButton.addEventListener('click', async () => {
      if (!isRecording) {
        await startRecording();
      }
    });

    stopRecordingBtn.addEventListener('click', () => {
      if (isRecording) {
        stopRecording();
      }
    });

    // è¯·æ±‚å½•éŸ³æƒé™
    async function requestAudioPermission() {
      return new Promise((resolve) => {
        if (window.cordova && cordova.plugins && cordova.plugins.permissions) {
          const permissions = cordova.plugins.permissions;
          permissions.checkPermission(permissions.RECORD_AUDIO, (status) => {
            if (status.hasPermission) {
              resolve(true);
            } else {
              permissions.requestPermission(permissions.RECORD_AUDIO, (status) => {
                resolve(status.hasPermission);
              }, () => resolve(false));
            }
          }, () => resolve(false));
        } else {
          // å¦‚æœæ²¡æœ‰æƒé™æ’ä»¶ï¼Œç›´æ¥å°è¯•è·å–éº¦å…‹é£
          resolve(true);
        }
      });
    }

    async function startRecording() {
      try {
        // æ£€æŸ¥æƒé™
        const hasPermission = await requestAudioPermission();
        if (!hasPermission) {
          alert('éœ€è¦å½•éŸ³æƒé™æ‰èƒ½ä½¿ç”¨è¯­éŸ³åŠŸèƒ½');
          return;
        }

        initCanvas();

        // è·å–éŸ³é¢‘æµ
        const stream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            sampleRate: 16000,
            channelCount: 1,
            echoCancellation: true,
            noiseSuppression: true
          }
        });

        // è®¾ç½®MediaRecorder
        const options = {
          mimeType: 'audio/webm;codecs=opus'
        };
        
        // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒçš„æ ¼å¼
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
          options.mimeType = 'audio/webm';
          if (!MediaRecorder.isTypeSupported(options.mimeType)) {
            options.mimeType = 'audio/mp4';
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
              delete options.mimeType;
            }
          }
        }

        mediaRecorder = new MediaRecorder(stream, options);
        audioChunks = [];

        mediaRecorder.ondataavailable = e => {
          if (e.data.size > 0) audioChunks.push(e.data);
        };

        mediaRecorder.onstop = async () => {
          await processRecording();
        };

        // å®æ—¶æ³¢å½¢
        // è®¾ç½®éŸ³é¢‘åˆ†æå™¨ç”¨äºæ³¢å½¢æ˜¾ç¤º
        audioContext = new (window.AudioContext || window.webkitAudioContext)({
          sampleRate: 16000
        });
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        source.connect(analyser);
        drawWaveform();

        // UIåˆ‡æ¢
        chatInputContainer.style.display = 'none';
        recordingContainer.style.display = 'flex';

        mediaRecorder.start();
        isRecording = true;
        console.log('å½•éŸ³å¼€å§‹');
      } catch (err) {
        console.error('æ— æ³•è®¿é—®éº¦å…‹é£:', err);
      }
    }

    function stopRecording() {
      isRecording = false;
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }

      // åœæ­¢æ‰€æœ‰éŸ³é¢‘è½¨é“
      if (mediaRecorder && mediaRecorder.stream) {
        mediaRecorder.stream.getTracks().forEach(track => track.stop());
      }

      // åœæ­¢æ³¢å½¢åŠ¨ç”»
      if (animationId) {
        cancelAnimationFrame(animationId);
      }

      // UIåˆ‡æ¢å›èŠå¤©è¾“å…¥
      chatInputContainer.style.display = 'flex';
      recordingContainer.style.display = 'none';
    }

    async function processRecording() {
      try {
        // åˆ›å»ºéŸ³é¢‘blob
        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        
        // è½¬æ¢ä¸ºArrayBuffer
        const arrayBuffer = await audioBlob.arrayBuffer();
        
        // è§£ç éŸ³é¢‘æ•°æ®
        const audioBufferObj = await audioContext.decodeAudioData(arrayBuffer);
        
        // ç¡®ä¿æ˜¯16kHzå•å£°é“
        const targetSampleRate = 16000;
        let audioData = audioBufferObj.getChannelData(0);
        
        // å¦‚æœé‡‡æ ·ç‡ä¸æ˜¯16kHzï¼Œè¿›è¡Œé‡é‡‡æ ·
        if (audioBufferObj.sampleRate !== targetSampleRate) {
          audioData = downsampleBuffer(audioData, audioBufferObj.sampleRate, targetSampleRate);
        }
        
        // è½¬æ¢ä¸º16ä½PCM
        const int16Data = floatTo16BitPCM(audioData);
        
        // åˆ›å»ºWAVæ–‡ä»¶
        const wavBuffer = createWAVFile(int16Data, targetSampleRate);
        
        // ä¿å­˜æ–‡ä»¶åˆ°Cordovaæ–‡ä»¶ç³»ç»Ÿ
        const savedFilePath = await saveAudioFile(wavBuffer);
        
        // è°ƒç”¨ASR API
        const transcription = await performASR(savedFilePath);
        
        if (transcription && transcription.trim()) {
          // å¤„ç†è¯†åˆ«ç»“æœï¼Œç±»ä¼¼åŸæ¥çš„sendMessageé€»è¾‘
          await handleTranscription(transcription, savedFilePath);
        } else {
          console.log('æ²¡æœ‰è¯†åˆ«åˆ°æœ‰æ•ˆå†…å®¹');
        }
        
      } catch (error) {
        console.error('å¤„ç†å½•éŸ³æ—¶å‡ºé”™:', error);
        alert('å½•éŸ³å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•');
      }
    }

    // é‡é‡‡æ ·å‡½æ•°
    function downsampleBuffer(buffer, sampleRate, targetRate) {
      if (targetRate === sampleRate) return buffer;
      const sampleRateRatio = sampleRate / targetRate;
      const newLength = Math.round(buffer.length / sampleRateRatio);
      const result = new Float32Array(newLength);
      let offsetResult = 0;
      let offsetBuffer = 0;
      
      while (offsetResult < result.length) {
        const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
        let accum = 0, count = 0;
        for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
          accum += buffer[i];
          count++;
        }
        result[offsetResult] = accum / count;
        offsetResult++;
        offsetBuffer = nextOffsetBuffer;
      }
      return result;
    }

    // è½¬æ¢ä¸º16ä½PCM
    function floatTo16BitPCM(float32Array) {
      const buffer = new ArrayBuffer(float32Array.length * 2);
      const view = new DataView(buffer);
      let offset = 0;
      for (let i = 0; i < float32Array.length; i++, offset += 2) {
        let s = Math.max(-1, Math.min(1, float32Array[i]));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
      }
      return new Int16Array(buffer);
    }

    // åˆ›å»ºWAVæ–‡ä»¶
    function createWAVFile(audioData, sampleRate) {
      const length = audioData.length;
      const buffer = new ArrayBuffer(44 + length * 2);
      const view = new DataView(buffer);
      
      // WAVæ–‡ä»¶å¤´
      const writeString = (offset, string) => {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      };
      
      writeString(0, 'RIFF');
      view.setUint32(4, 36 + length * 2, true);
      writeString(8, 'WAVE');
      writeString(12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, 1, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * 2, true);
      view.setUint16(32, 2, true);
      view.setUint16(34, 16, true);
      writeString(36, 'data');
      view.setUint32(40, length * 2, true);
      
      // å†™å…¥éŸ³é¢‘æ•°æ®
      let offset = 44;
      for (let i = 0; i < audioData.length; i++) {
        view.setInt16(offset, audioData[i], true);
        offset += 2;
      }
      
      return buffer;
    }

    // ä¿å­˜éŸ³é¢‘æ–‡ä»¶åˆ°Cordovaæ–‡ä»¶ç³»ç»Ÿ
    async function saveAudioFile(wavBuffer) {
      return new Promise((resolve, reject) => {
        // ç¡®ä¿Cordova fileæ’ä»¶å¯ç”¨
        if (!window.cordova || !window.cordova.file) {
          reject(new Error('Cordova file plugin not available'));
          return;
        }

        window.resolveLocalFileSystemURL(cordova.file.dataDirectory, (dirEntry) => {
          // åˆ›å»ºchat_wavç›®å½•
          dirEntry.getDirectory('chat_wav', { create: true }, (chatWavDir) => {
            // åˆ›å»ºå½“å‰ä¼šè¯ç›®å½•
            chatWavDir.getDirectory(currentSessionId, { create: true }, (sessionDir) => {
              // ç”Ÿæˆæ–‡ä»¶å
              const fileName = `recording_${Date.now()}.wav`;
              
              // åˆ›å»ºæ–‡ä»¶
              sessionDir.getFile(fileName, { create: true }, (fileEntry) => {
                // å†™å…¥æ–‡ä»¶
                fileEntry.createWriter((fileWriter) => {
                  fileWriter.onwriteend = () => {
                    console.log('éŸ³é¢‘æ–‡ä»¶ä¿å­˜æˆåŠŸ:', fileEntry.nativeURL);
                    resolve(fileEntry.nativeURL);
                  };
                  
                  fileWriter.onerror = (e) => {
                    console.error('æ–‡ä»¶å†™å…¥å¤±è´¥:', e);
                    reject(e);
                  };
                  
                  // å°†ArrayBufferè½¬æ¢ä¸ºBlob
                  const blob = new Blob([wavBuffer], { type: 'audio/wav' });
                  fileWriter.write(blob);
                });
              }, reject);
            }, reject);
          }, reject);
        }, reject);
      });
    }

    // è°ƒç”¨ASR API
    async function performASR(audioFilePath) {
      try {
        console.log('Starting ASR with filePath:', audioFilePath);
        const audioFile = await readAudioFile(audioFilePath);
        
        if (!(audioFile instanceof Blob)) {
          throw new Error('Invalid audio file: not a Blob or File object');
        }

        const formData = new FormData();
        formData.append('audio', audioFile, 'recording.wav');
        console.log('FormData prepared, audioFile size:', audioFile.size, 'type:', audioFile.type);

        // è°ƒç”¨ASR API
        const response = await fetch('https://192.168.31.71:5000/asr', {
          method: 'POST',
          body: formData
        });

        if (!response.ok) {
          throw new Error(`ASR API request failed: ${response.status}`);
        }

        const result = await response.json();

        if (!result.success) {
          throw new Error(result.error || 'ASR processing failed');
        }

        // æ ¹æ®APIè¿”å›æ ¼å¼è·å–è¯†åˆ«ç»“æœ
        return result.transcription || '';

      } catch (error) {
        console.error('ASRè°ƒç”¨å¤±è´¥:', error);
        return '';
      }
    }

    // è¯»å–éŸ³é¢‘æ–‡ä»¶ï¼ˆç”¨äºå‘é€åˆ°ASR APIï¼‰
    function readAudioFile(filePath) {
      return new Promise((resolve, reject) => {
        console.log('Resolving file system URL:', filePath);
        window.resolveLocalFileSystemURL(filePath, (fileEntry) => {
          console.log('File entry resolved:', fileEntry.name);
          fileEntry.file(
            (file) => {
              console.log('File loaded (raw):', {
                name: file.name,
                size: file.size,
                type: file.type,
                isFile: file instanceof File,
                isBlob: file instanceof Blob
              });

              // ä½¿ç”¨ FileReader è¯»å–æ–‡ä»¶å†…å®¹å¹¶åˆ›å»º Blob
              const reader = new FileReader();
              reader.onloadend = () => {
                const arrayBuffer = reader.result;
                const blob = new Blob([arrayBuffer], { type: file.type || 'audio/wav' });
                console.log('Converted to Blob:', {
                  size: blob.size,
                  type: blob.type,
                  isBlob: blob instanceof Blob
                });
                resolve(blob);
              };
              reader.onerror = (error) => {
                console.error('FileReader error:', error);
                reject(new Error('Failed to read file content: ' + error.message));
              };
              reader.readAsArrayBuffer(file);
            },
            (error) => {
              console.error('Failed to read file:', error);
              reject(new Error('Failed to read audio file: ' + error.message));
            }
          );
        }, (error) => {
          console.error('Invalid file path:', filePath, error);
          reject(new Error('Invalid file path: ' + error.message));
        });
      });
    }

    // å¤„ç†è½¬å½•ç»“æœ
    async function handleTranscription(transcription, audioFilePath) {
      try {
        if (!transcription || !currentSessionId) return;
        
        // è·å–ä¸Šä¼ çš„æ–‡ä»¶è·¯å¾„
        let files_path = [];
        for (const file of uploadedFiles) {
          files_path.push(file.path);
        }

        // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
        addMessage(transcription, true, audioFilePath, files_path);
        
        // é‡ç½®è¾“å…¥æ¡†
        if (chatInput) {
          chatInput.value = '';
          resetTextareaHeight();
        }
        
        // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
        if (sendButton) {
          sendButton.disabled = true;
          sendButton.innerHTML = '<div class="loading" style="width: 16px; height: 16px; border-width: 1px;"></div>';
        }
        showLoading();

        // æ¸…ç©ºfilesåˆ—è¡¨
        uploadedFiles = [];
        updateUploadedFilesDisplay();

        await addMessageToSession(currentSessionId, 'user', transcription, audioFilePath, files_path);
        
        // è·å–ä¼šè¯å†å²
        const history = await getSessionHistory(currentSessionId);

        // è°ƒç”¨æœåŠ¡å™¨è·å–å›å¤
        const response = await getModelResponse(transcription, history, isVoiceEnabled);
        const tts_success = await getTTSWav(response)
        // saveTestWavToDataDirectory()
        simulateLive2DClick()
        
        hideLoading();
        addMessage(response);
        
        // æ·»åŠ åŠ©æ‰‹å›å¤åˆ°å†å²æ–‡ä»¶
        await addMessageToSession(currentSessionId, 'assistant', response);

        // æ›´æ–°ä¼šè¯åˆ—è¡¨
        sessions = await getAllSessions();
        renderSessionsList();
      } catch (error) {
        hideLoading();
        addMessage('æŠ±æ­‰ï¼Œå‡ºç°äº†ä¸€äº›é—®é¢˜ï¼Œè¯·ç¨åå†è¯•ã€‚');
        console.error('å¤„ç†è½¬å½•ç»“æœæ—¶å‡ºé”™:', error);
      } finally {
        if (sendButton) {
          sendButton.disabled = false;
          sendButton.innerHTML = '<span>â†’</span>';
        }
      }
    }

    function drawWaveform() {
      if (!analyser || !dataArray) {
        console.error('Analyser or dataArray not initialized');
        return;
      }
      if (waveformCanvas.width === 0 || waveformCanvas.height === 0) {
        console.warn('Canvas has invalid dimensions, reinitializing');
        initCanvas();
      }
      animationId = requestAnimationFrame(drawWaveform);
      analyser.getByteTimeDomainData(dataArray);
      console.log('Waveform data sample:', dataArray.slice(0, 10)); // è°ƒè¯•æ•°æ®
      ctx.fillStyle = '#f0f0f0';
      ctx.fillRect(0, 0, waveformCanvas.width, waveformCanvas.height);
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#4CAF50';
      ctx.beginPath();
      const sliceWidth = waveformCanvas.width / dataArray.length;
      let x = 0;
      const amplitudeScale = 1; // æ”¾å¤§æŒ¯å¹…
      for (let i = 0; i < dataArray.length; i++) {
        const v = dataArray[i] / 128.0 * amplitudeScale;
        const y = (v * waveformCanvas.height) / 2;
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
        x += sliceWidth;
      }
      ctx.lineTo(waveformCanvas.width, waveformCanvas.height / 2);
      ctx.stroke();
    }

    // åœ¨å…¨å±€å˜é‡éƒ¨åˆ†æ·»åŠ 
    let uploadedFiles = [];

    // æ·»åŠ æ–‡ä»¶ä¸Šä¼ ç›¸å…³å‡½æ•°
    function initFileUpload() {
      const fileUploadButton = document.getElementById('file-upload-button');
      const fileInput = document.getElementById('file-input');
      
      fileUploadButton.addEventListener('click', () => {
        fileInput.click();
      });
      
      fileInput.addEventListener('change', handleFileSelect);
    }

    async function handleFileSelect(event) {
      const files = Array.from(event.target.files);
      
      for (const file of files) {
        try {
          // å…ˆè½¬æˆ ArrayBuffer
          const arrayBuffer = await file.arrayBuffer();
          
          // å‘åˆ°ä¸»è¿›ç¨‹
          const savedPath = await ipcRenderer.invoke('save-uploaded-file', {
            fileName: file.name,
            buffer: Buffer.from(arrayBuffer), // è½¬ Node Buffer
            sessionId: currentSessionId
          });

          uploadedFiles.push({
            name: file.name,
            size: file.size,
            type: file.type,
            path: savedPath
          });
        } catch (error) {
          console.error('æ–‡ä»¶ä¸Šä¼ å¤±è´¥:', error);
        }
      }
      
      updateUploadedFilesDisplay();
      event.target.value = ''; // æ¸…ç©º input
    }

    function showImagePreview(filePath) {
      const overlay = document.createElement('div');
      overlay.style.position = 'fixed';
      overlay.style.top = '0';
      overlay.style.left = '0';
      overlay.style.width = '100%';
      overlay.style.height = '100%';
      overlay.style.backgroundColor = 'rgba(0,0,0,0.7)';
      overlay.style.display = 'flex';
      overlay.style.justifyContent = 'center';
      overlay.style.alignItems = 'center';
      overlay.style.zIndex = '9999';
      overlay.style.cursor = 'zoom-out';

      const img = document.createElement('img');
      img.src = filePath;
      img.style.maxWidth = '90%';
      img.style.maxHeight = '90%';
      img.style.borderRadius = '8px';
      img.style.boxShadow = '0 4px 20px rgba(0,0,0,0.5)';

      overlay.appendChild(img);
      document.body.appendChild(overlay);

      overlay.addEventListener('click', () => {
        document.body.removeChild(overlay);
      });
    }

    function updateUploadedFilesDisplay() {
      const container = document.getElementById('uploaded-files-container');
      const list = document.getElementById('uploaded-files-list');
      
      // æ·»åŠ é”™è¯¯æ£€æŸ¥
      if (!container || !list) {
        console.error('æ–‡ä»¶æ˜¾ç¤ºå®¹å™¨æœªæ‰¾åˆ°');
        return;
      }
      
      if (uploadedFiles.length === 0) {
        container.style.display = 'none';
        return;
      }
      
      container.style.display = 'block';
      list.innerHTML = '';

      uploadedFiles.forEach((file, index) => {
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';

        const fileIcon = getFileIcon(file.name);

        fileItem.innerHTML = `
          <span class="file-icon" style="margin-right: 4px; cursor: pointer;" title="ç‚¹å‡»æ‰“å¼€">${fileIcon}</span>
          <span class="file-name" title="${file.name}" style="cursor: pointer;">${file.name}</span>
          <button class="file-remove-btn" data-index="${index}" title="åˆ é™¤æ–‡ä»¶">Ã—</button>
        `;

        const iconSpan = fileItem.querySelector('.file-icon');
        const nameSpan = fileItem.querySelector('.file-name');

        // ç‚¹å‡»æ–‡ä»¶ -> åˆ¤æ–­ç±»å‹
        [iconSpan, nameSpan].forEach(el => {
          el.addEventListener('click', (e) => {
            e.stopPropagation();
            const ext = file.name.split('.').pop().toLowerCase();

            if (['png', 'jpg', 'jpeg', 'gif', 'webp'].includes(ext)) {
              showImagePreview(file.path); // âœ… åº”ç”¨å†…é¢„è§ˆ
            } else {
              ipcRenderer.invoke('open-file', file.path); // âœ… ç³»ç»Ÿé»˜è®¤ç¨‹åº
            }
          });
        });

        // åˆ é™¤æŒ‰é’®
        const removeBtn = fileItem.querySelector('.file-remove-btn');
        removeBtn.addEventListener('click', (e) => {
          e.stopPropagation(); 
          removeFile(index);
        });

        list.appendChild(fileItem);
      });
    }

    // æ·»åŠ æ–‡ä»¶å›¾æ ‡å‡½æ•°
    function getFileIcon(fileName) {
      const ext = fileName.split('.').pop().toLowerCase();
      const iconMap = {
        'txt': 'ğŸ“„',
        'pdf': 'ğŸ“•',
        'doc': 'ğŸ“˜',
        'docx': 'ğŸ“˜',
        'png': 'ğŸ–¼ï¸',
        'jpg': 'ğŸ–¼ï¸',
        'jpeg': 'ğŸ–¼ï¸',
        'gif': 'ğŸ–¼ï¸',
        'mp3': 'ğŸµ',
        'mp4': 'ğŸ¬',
        'zip': 'ğŸ“¦',
        'rar': 'ğŸ“¦'
      };
      return iconMap[ext] || 'ğŸ“';
    }

    async function removeFile(index) {
      const file = uploadedFiles[index];
      
      try {
        await ipcRenderer.invoke('remove-uploaded-file', {
          filePath: file.path,
          sessionId: currentSessionId
        });
        
        uploadedFiles.splice(index, 1);
        updateUploadedFilesDisplay();
      } catch (error) {
        console.error('åˆ é™¤æ–‡ä»¶å¤±è´¥:', error);
      }
    }
  </script>
</body>
</html>